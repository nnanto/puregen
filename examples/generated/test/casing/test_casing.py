# Code generated by protoc-gen-puregen. DO NOT EDIT.

from dataclasses import dataclass, field
from typing import Optional, List, Dict, Any
from abc import ABC, abstractmethod
import json

# Messages

@dataclass
class TestMessage:
    """Generated message class for TestMessage"""
    # puregen:metadata: {"urls": "http://example.com/api/test"}
    api_host: str = ""
    tpm_data: str = ""
    xml_content: str = ""
    url_path: str = ""
    https_enabled: str = ""
    uuid_value: str = ""
    json_data: str = ""
    api_key: str = ""
    sql_query: str = ""
    html_content: str = ""

    def validate(self) -> bool:
        """Validate the message fields"""
        # Add custom validation logic here
        return True

    def to_json(self) -> str:
        """Convert message to JSON string"""
        return json.dumps(self.to_dict())

    def to_dict(self) -> Dict[str, Any]:
        """Convert message to dictionary"""
        result = {}
        if self.api_host is not None:
            result['APIHost'] = self.api_host
        if self.tpm_data is not None:
            result['TPMData'] = self.tpm_data
        if self.xml_content is not None:
            result['XMLContent'] = self.xml_content
        if self.url_path is not None:
            result['URLPath'] = self.url_path
        if self.https_enabled is not None:
            result['HTTPSEnabled'] = self.https_enabled
        if self.uuid_value is not None:
            result['UUIDValue'] = self.uuid_value
        if self.json_data is not None:
            result['JSONData'] = self.json_data
        if self.api_key is not None:
            result['APIKey'] = self.api_key
        if self.sql_query is not None:
            result['SQLQuery'] = self.sql_query
        if self.html_content is not None:
            result['HTMLContent'] = self.html_content
        return result

    @classmethod
    def from_json(cls, json_str: str) -> 'TestMessage':
        """Create message from JSON string"""
        data = json.loads(json_str)
        return cls.from_dict(data)

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'TestMessage':
        """Create message from dictionary"""
        kwargs = {}
        if 'APIHost' in data:
            kwargs['api_host'] = data['APIHost']
        if 'TPMData' in data:
            kwargs['tpm_data'] = data['TPMData']
        if 'XMLContent' in data:
            kwargs['xml_content'] = data['XMLContent']
        if 'URLPath' in data:
            kwargs['url_path'] = data['URLPath']
        if 'HTTPSEnabled' in data:
            kwargs['https_enabled'] = data['HTTPSEnabled']
        if 'UUIDValue' in data:
            kwargs['uuid_value'] = data['UUIDValue']
        if 'JSONData' in data:
            kwargs['json_data'] = data['JSONData']
        if 'APIKey' in data:
            kwargs['api_key'] = data['APIKey']
        if 'SQLQuery' in data:
            kwargs['sql_query'] = data['SQLQuery']
        if 'HTMLContent' in data:
            kwargs['html_content'] = data['HTMLContent']
        return cls(**kwargs)

# Field name constants for TestMessage
TestMessage_APIHost_FIELD = "TestMessage_APIHost"

# MessageField metadata for TestMessage
TestMessageFieldMetadata = {
    TestMessage_APIHost_FIELD: {
        "urls": "http://example.com/api/test",
    },
}

