# Code generated by protoc-gen-puregen. DO NOT EDIT.

from dataclasses import dataclass, field
from typing import Optional, List, Dict, Any
from abc import ABC, abstractmethod
import json
from .puregen_transport import PuregenTransport

# Enums

# Example enum with metadata for validation and UI
class TaskStatus:
    """TaskStatus enum values as string constants"""
    UNKNOWN = "UNKNOWN"
    PENDING = "PENDING"
    IN_PROGRESS = "IN_PROGRESS"
    COMPLETED = "COMPLETED"
    CANCELLED = "CANCELLED"

    VALUES = [
        UNKNOWN,
        PENDING,
        IN_PROGRESS,
        COMPLETED,
        CANCELLED,
    ]

    @classmethod
    def is_valid(cls, value: str) -> bool:
        """Check if value is a valid TaskStatus"""
        return value in cls.VALUES

# Metadata for TaskStatus
TaskStatusMetadata = {
    "category": "status",
    "ui_type": "dropdown",
    "validation": "required",
}

# Messages

# Example message with metadata for database mapping
@dataclass
class Task:
    """Generated message class for Task"""
    # Primary key field with validation metadata
    id: str = ""
    # Required field with length constraints
    title: str = ""
    # Optional field with UI metadata
    description: str = ""
    # Status field with validation and default value
    status: str = 0
    # Timestamp field with format metadata
    created_at: int = 0

    def validate(self) -> bool:
        """Validate the message fields"""
        # Add custom validation logic here
        return True

    def to_json(self) -> str:
        """Convert message to JSON string"""
        return json.dumps(self.to_dict())

    def to_dict(self) -> Dict[str, Any]:
        """Convert message to dictionary"""
        result = {}
        if self.id is not None:
            result['id'] = self.id
        if self.title is not None:
            result['title'] = self.title
        if self.description is not None:
            result['description'] = self.description
        if self.status is not None:
            result['status'] = self.status
        if self.created_at is not None:
            result['createdAt'] = self.created_at
        return result

    @classmethod
    def from_json(cls, json_str: str) -> 'Task':
        """Create message from JSON string"""
        data = json.loads(json_str)
        return cls.from_dict(data)

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'Task':
        """Create message from dictionary"""
        kwargs = {}
        if 'id' in data:
            kwargs['id'] = data['id']
        if 'title' in data:
            kwargs['title'] = data['title']
        if 'description' in data:
            kwargs['description'] = data['description']
        if 'status' in data:
            kwargs['status'] = data['status']
        if 'createdAt' in data:
            kwargs['created_at'] = data['createdAt']
        return cls(**kwargs)

# Metadata for Task
TaskMetadata = {
    "cache": "true",
    "partition_key": "user_id",
    "table": "tasks",
}

# Field name constants for Task
Task_Id_FIELD = "Task_Id"
Task_Title_FIELD = "Task_Title"
Task_Description_FIELD = "Task_Description"
Task_Status_FIELD = "Task_Status"
Task_CreatedAt_FIELD = "Task_CreatedAt"

# MessageField metadata for Task
TaskFieldMetadata = {
    Task_Id_FIELD: {
        "db_column": "task_id",
        "index": "primary",
        "validation": "uuid",
    },
    Task_Title_FIELD: {
        "max_length": "200",
        "min_length": "1",
        "validation": "required",
    },
    Task_Description_FIELD: {
        "placeholder": "Enter task description...",
        "ui_widget": "textarea",
    },
    Task_Status_FIELD: {
        "default": "PENDING",
        "required": "true",
        "validation": "enum",
    },
    Task_CreatedAt_FIELD: {
        "format": "unix_timestamp",
        "index": "secondary",
    },
}

@dataclass
class CreateTaskRequest:
    """Generated message class for CreateTaskRequest"""
    # Required fields for task creation
    title: str = ""
    description: str = ""

    def validate(self) -> bool:
        """Validate the message fields"""
        # Add custom validation logic here
        return True

    def to_json(self) -> str:
        """Convert message to JSON string"""
        return json.dumps(self.to_dict())

    def to_dict(self) -> Dict[str, Any]:
        """Convert message to dictionary"""
        result = {}
        if self.title is not None:
            result['title'] = self.title
        if self.description is not None:
            result['description'] = self.description
        return result

    @classmethod
    def from_json(cls, json_str: str) -> 'CreateTaskRequest':
        """Create message from JSON string"""
        data = json.loads(json_str)
        return cls.from_dict(data)

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'CreateTaskRequest':
        """Create message from dictionary"""
        kwargs = {}
        if 'title' in data:
            kwargs['title'] = data['title']
        if 'description' in data:
            kwargs['description'] = data['description']
        return cls(**kwargs)

# Field name constants for CreateTaskRequest
CreateTaskRequest_Title_FIELD = "CreateTaskRequest_Title"

# MessageField metadata for CreateTaskRequest
CreateTaskRequestFieldMetadata = {
    CreateTaskRequest_Title_FIELD: {
        "trim_whitespace": "true",
        "validation": "required",
    },
}

@dataclass
class CreateTaskResponse:
    """Generated message class for CreateTaskResponse"""
    task: Optional['Task'] = None

    def validate(self) -> bool:
        """Validate the message fields"""
        # Add custom validation logic here
        return True

    def to_json(self) -> str:
        """Convert message to JSON string"""
        return json.dumps(self.to_dict())

    def to_dict(self) -> Dict[str, Any]:
        """Convert message to dictionary"""
        result = {}
        if self.task is not None:
            result['task'] = self.task.to_dict() if hasattr(self.task, 'to_dict') else self.task
        return result

    @classmethod
    def from_json(cls, json_str: str) -> 'CreateTaskResponse':
        """Create message from JSON string"""
        data = json.loads(json_str)
        return cls.from_dict(data)

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'CreateTaskResponse':
        """Create message from dictionary"""
        kwargs = {}
        if 'task' in data:
            kwargs['task'] = Task.from_dict(data['task']) if isinstance(data['task'], dict) else data['task']
        return cls(**kwargs)

@dataclass
class GetTaskRequest:
    """Generated message class for GetTaskRequest"""
    # 
    id: str = ""

    def validate(self) -> bool:
        """Validate the message fields"""
        # Add custom validation logic here
        return True

    def to_json(self) -> str:
        """Convert message to JSON string"""
        return json.dumps(self.to_dict())

    def to_dict(self) -> Dict[str, Any]:
        """Convert message to dictionary"""
        result = {}
        if self.id is not None:
            result['id'] = self.id
        return result

    @classmethod
    def from_json(cls, json_str: str) -> 'GetTaskRequest':
        """Create message from JSON string"""
        data = json.loads(json_str)
        return cls.from_dict(data)

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'GetTaskRequest':
        """Create message from dictionary"""
        kwargs = {}
        if 'id' in data:
            kwargs['id'] = data['id']
        return cls(**kwargs)

# Field name constants for GetTaskRequest
GetTaskRequest_Id_FIELD = "GetTaskRequest_Id"

# MessageField metadata for GetTaskRequest
GetTaskRequestFieldMetadata = {
    GetTaskRequest_Id_FIELD: {
        "validation": "uuid",
    },
}

@dataclass
class GetTaskResponse:
    """Generated message class for GetTaskResponse"""
    task: Optional['Task'] = None

    def validate(self) -> bool:
        """Validate the message fields"""
        # Add custom validation logic here
        return True

    def to_json(self) -> str:
        """Convert message to JSON string"""
        return json.dumps(self.to_dict())

    def to_dict(self) -> Dict[str, Any]:
        """Convert message to dictionary"""
        result = {}
        if self.task is not None:
            result['task'] = self.task.to_dict() if hasattr(self.task, 'to_dict') else self.task
        return result

    @classmethod
    def from_json(cls, json_str: str) -> 'GetTaskResponse':
        """Create message from JSON string"""
        data = json.loads(json_str)
        return cls.from_dict(data)

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'GetTaskResponse':
        """Create message from dictionary"""
        kwargs = {}
        if 'task' in data:
            kwargs['task'] = Task.from_dict(data['task']) if isinstance(data['task'], dict) else data['task']
        return cls(**kwargs)

# Services

# Example service with method metadata
class TaskServiceService(ABC):
    """Abstract service interface for TaskService"""

    # Create task endpoint with HTTP mapping
    @abstractmethod
    def create_task(self, ctx: Dict[str, Any], request: CreateTaskRequest) -> CreateTaskResponse:
        """CreateTask method"""
        pass

    # Get task endpoint with caching
    @abstractmethod
    def get_task(self, ctx: Dict[str, Any], request: GetTaskRequest) -> GetTaskResponse:
        """GetTask method"""
        pass

class DefaultTaskServiceService(TaskServiceService):
    """Default implementation of TaskServiceService"""

    # Create task endpoint with HTTP mapping
    def create_task(self, ctx: Dict[str, Any], request: CreateTaskRequest) -> CreateTaskResponse:
        """CreateTask method implementation"""
        # TODO: Implement create_task
        raise NotImplementedError("Method create_task not implemented")

    # Get task endpoint with caching
    def get_task(self, ctx: Dict[str, Any], request: GetTaskRequest) -> GetTaskResponse:
        """GetTask method implementation"""
        # TODO: Implement get_task
        raise NotImplementedError("Method get_task not implemented")

# Method name constants

class TaskServiceMethods:
    """Method name constants for TaskService"""
    TaskService_CreateTask = "TaskService_CreateTask"
    TaskService_GetTask = "TaskService_GetTask"

    METHOD_METADATA = {
        TaskService_CreateTask: {
            "auth": "required",
            "method": "POST",
            "path": "/api/v1/tasks",
        },
        TaskService_GetTask: {
            "cache": "true",
            "cache_ttl": "300",
            "method": "GET",
            "path": "/api/v1/tasks/{id}",
        },
    }

# Client

class TaskServiceClient:
    """Client for TaskService service"""

    def __init__(self, transport: PuregenTransport):
        self.transport = transport

    def create_task(self, ctx: Dict[str, Any], request: CreateTaskRequest) -> CreateTaskResponse:
        """CreateTask client method"""
        enhanced_ctx = ctx.copy() if ctx else {}
        method_metadata = TaskServiceMethods.METHOD_METADATA.get(TaskServiceMethods.TaskService_CreateTask, {})
        enhanced_ctx['method_metadata'] = method_metadata
        result = self.transport.send(enhanced_ctx, TaskServiceMethods.TaskService_CreateTask, request, CreateTaskResponse)
        if isinstance(result, CreateTaskResponse):
            return result
        if isinstance(result, dict):
            return CreateTaskResponse.from_dict(result)
        raise ValueError(f"Invalid response type for create_task: {type(result)}")

    def get_task(self, ctx: Dict[str, Any], request: GetTaskRequest) -> GetTaskResponse:
        """GetTask client method"""
        enhanced_ctx = ctx.copy() if ctx else {}
        method_metadata = TaskServiceMethods.METHOD_METADATA.get(TaskServiceMethods.TaskService_GetTask, {})
        enhanced_ctx['method_metadata'] = method_metadata
        result = self.transport.send(enhanced_ctx, TaskServiceMethods.TaskService_GetTask, request, GetTaskResponse)
        if isinstance(result, GetTaskResponse):
            return result
        if isinstance(result, dict):
            return GetTaskResponse.from_dict(result)
        raise ValueError(f"Invalid response type for get_task: {type(result)}")

