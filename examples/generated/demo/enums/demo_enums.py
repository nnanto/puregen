# Code generated by protoc-gen-puregen. DO NOT EDIT.

from dataclasses import dataclass, field
from typing import Optional, List, Dict, Any
from abc import ABC, abstractmethod
import json
from enum import IntEnum
from .puregen_transport import PuregenTransport

# Enums

# Status enum should be generated as integers
class Status(IntEnum):
    """Status enum values as integers"""
    STATUS_UNKNOWN = 0
    STATUS_ACTIVE = 1
    STATUS_INACTIVE = 2
    STATUS_SUSPENDED = 3

    @classmethod
    def is_valid(cls, value: int) -> bool:
        """Check if value is a valid Status"""
        return value in [item.value for item in cls]

# Priority enum should be generated as string constants (default)
class Priority:
    """Priority enum values as string constants"""
    PRIORITY_LOW = "PRIORITY_LOW"
    PRIORITY_MEDIUM = "PRIORITY_MEDIUM"
    PRIORITY_HIGH = "PRIORITY_HIGH"
    PRIORITY_CRITICAL = "PRIORITY_CRITICAL"

    VALUES = [
        PRIORITY_LOW,
        PRIORITY_MEDIUM,
        PRIORITY_HIGH,
        PRIORITY_CRITICAL,
    ]

    @classmethod
    def is_valid(cls, value: str) -> bool:
        """Check if value is a valid Priority"""
        return value in cls.VALUES

# 
class Task_Type(IntEnum):
    """Task_Type enum values as integers"""
    TYPE_UNKNOWN = 0
    TYPE_BUG = 1
    TYPE_FEATURE = 2
    TYPE_ENHANCEMENT = 3

    @classmethod
    def is_valid(cls, value: int) -> bool:
        """Check if value is a valid Task_Type"""
        return value in [item.value for item in cls]

# Messages

# Type enum nested in message should also be integers
@dataclass
class Task:
    """Generated message class for Task"""
    id: str = ""
    title: str = ""
    status: int = 0
    priority: str = 0
    type: int = 0

    def validate(self) -> bool:
        """Validate the message fields"""
        # Add custom validation logic here
        return True

    def to_json(self) -> str:
        """Convert message to JSON string"""
        return json.dumps(self.to_dict())

    def to_dict(self) -> Dict[str, Any]:
        """Convert message to dictionary"""
        result = {}
        if self.id is not None:
            result['id'] = self.id
        if self.title is not None:
            result['title'] = self.title
        if self.status is not None:
            result['status'] = self.status
        if self.priority is not None:
            result['priority'] = self.priority
        if self.type is not None:
            result['type'] = self.type
        return result

    @classmethod
    def from_json(cls, json_str: str) -> 'Task':
        """Create message from JSON string"""
        data = json.loads(json_str)
        return cls.from_dict(data)

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'Task':
        """Create message from dictionary"""
        kwargs = {}
        if 'id' in data:
            kwargs['id'] = data['id']
        if 'title' in data:
            kwargs['title'] = data['title']
        if 'status' in data:
            kwargs['status'] = data['status']
        if 'priority' in data:
            kwargs['priority'] = data['priority']
        if 'type' in data:
            kwargs['type'] = data['type']
        return cls(**kwargs)

@dataclass
class TaskList:
    """Generated message class for TaskList"""
    tasks: List['Task'] = field(default_factory=list)

    def validate(self) -> bool:
        """Validate the message fields"""
        # Add custom validation logic here
        return True

    def to_json(self) -> str:
        """Convert message to JSON string"""
        return json.dumps(self.to_dict())

    def to_dict(self) -> Dict[str, Any]:
        """Convert message to dictionary"""
        result = {}
        if self.tasks is not None:
            result['tasks'] = [item.to_dict() if hasattr(item, 'to_dict') else item for item in self.tasks]
        return result

    @classmethod
    def from_json(cls, json_str: str) -> 'TaskList':
        """Create message from JSON string"""
        data = json.loads(json_str)
        return cls.from_dict(data)

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'TaskList':
        """Create message from dictionary"""
        kwargs = {}
        if 'tasks' in data:
            kwargs['tasks'] = [Task.from_dict(item) if isinstance(item, dict) else item for item in data['tasks']]
        return cls(**kwargs)

# Services

class TaskServiceService(ABC):
    """Abstract service interface for TaskService"""

    @abstractmethod
    def create_task(self, ctx: Dict[str, Any], request: Task) -> Task:
        """CreateTask method"""
        pass

    @abstractmethod
    def list_tasks(self, ctx: Dict[str, Any], request: TaskList) -> TaskList:
        """ListTasks method"""
        pass

class DefaultTaskServiceService(TaskServiceService):
    """Default implementation of TaskServiceService"""

    def create_task(self, ctx: Dict[str, Any], request: Task) -> Task:
        """CreateTask method implementation"""
        # TODO: Implement create_task
        raise NotImplementedError("Method create_task not implemented")

    def list_tasks(self, ctx: Dict[str, Any], request: TaskList) -> TaskList:
        """ListTasks method implementation"""
        # TODO: Implement list_tasks
        raise NotImplementedError("Method list_tasks not implemented")

# Method name constants

class TaskServiceMethods:
    """Method name constants for TaskService"""
    TaskService_CreateTask = "TaskService_CreateTask"
    TaskService_ListTasks = "TaskService_ListTasks"

    METHOD_METADATA = {
    }

# Client

class TaskServiceClient:
    """Client for TaskService service"""

    def __init__(self, transport: PuregenTransport):
        self.transport = transport

    def create_task(self, ctx: Dict[str, Any], request: Task) -> Task:
        """CreateTask client method"""
        enhanced_ctx = ctx.copy() if ctx else {}
        method_metadata = TaskServiceMethods.METHOD_METADATA.get(TaskServiceMethods.TaskService_CreateTask, {})
        enhanced_ctx['method_metadata'] = method_metadata
        result = self.transport.send(enhanced_ctx, TaskServiceMethods.TaskService_CreateTask, request, Task)
        if isinstance(result, Task):
            return result
        if isinstance(result, dict):
            return Task.from_dict(result)
        raise ValueError(f"Invalid response type for create_task: {type(result)}")

    def list_tasks(self, ctx: Dict[str, Any], request: TaskList) -> TaskList:
        """ListTasks client method"""
        enhanced_ctx = ctx.copy() if ctx else {}
        method_metadata = TaskServiceMethods.METHOD_METADATA.get(TaskServiceMethods.TaskService_ListTasks, {})
        enhanced_ctx['method_metadata'] = method_metadata
        result = self.transport.send(enhanced_ctx, TaskServiceMethods.TaskService_ListTasks, request, TaskList)
        if isinstance(result, TaskList):
            return result
        if isinstance(result, dict):
            return TaskList.from_dict(result)
        raise ValueError(f"Invalid response type for list_tasks: {type(result)}")

