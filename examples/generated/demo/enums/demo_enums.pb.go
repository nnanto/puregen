// Code generated by protoc-gen-puregen. DO NOT EDIT.

package enums

import (
	"context"
	"encoding/json"
	"fmt"
)

// Enums

type Status int32

const (
	Status_STATUS_UNKNOWN   Status = 0
	Status_STATUS_ACTIVE           = 1
	Status_STATUS_INACTIVE         = 2
	Status_STATUS_SUSPENDED        = 3
)

var Status_name = map[int32]string{
	0: "STATUS_UNKNOWN",
	1: "STATUS_ACTIVE",
	2: "STATUS_INACTIVE",
	3: "STATUS_SUSPENDED",
}

var Status_value = map[string]int32{
	"STATUS_UNKNOWN":   0,
	"STATUS_ACTIVE":    1,
	"STATUS_INACTIVE":  2,
	"STATUS_SUSPENDED": 3,
}

func (x Status) String() string {
	if name, ok := Status_name[int32(x)]; ok {
		return name
	}
	return fmt.Sprintf("Status(%d)", x)
}

func ParseStatus(s string) (Status, error) {
	if value, ok := Status_value[s]; ok {
		return Status(value), nil
	}
	return 0, fmt.Errorf("invalid Status value: %s", s)
}

func (x Status) IsValid() bool {
	_, ok := Status_name[int32(x)]
	return ok
}

// Priority enum values as string constants
const (
	Priority_PRIORITY_LOW      = "PRIORITY_LOW"
	Priority_PRIORITY_MEDIUM   = "PRIORITY_MEDIUM"
	Priority_PRIORITY_HIGH     = "PRIORITY_HIGH"
	Priority_PRIORITY_CRITICAL = "PRIORITY_CRITICAL"
)

var PriorityValues = []string{
	Priority_PRIORITY_LOW,
	Priority_PRIORITY_MEDIUM,
	Priority_PRIORITY_HIGH,
	Priority_PRIORITY_CRITICAL,
}

func IsValidPriority(value string) bool {
	for _, v := range PriorityValues {
		if v == value {
			return true
		}
	}
	return false
}

type Task_Type int32

const (
	Task_TYPE_UNKNOWN     Task_Type = 0
	Task_TYPE_BUG                   = 1
	Task_TYPE_FEATURE               = 2
	Task_TYPE_ENHANCEMENT           = 3
)

var Task_Type_name = map[int32]string{
	0: "TYPE_UNKNOWN",
	1: "TYPE_BUG",
	2: "TYPE_FEATURE",
	3: "TYPE_ENHANCEMENT",
}

var Task_Type_value = map[string]int32{
	"TYPE_UNKNOWN":     0,
	"TYPE_BUG":         1,
	"TYPE_FEATURE":     2,
	"TYPE_ENHANCEMENT": 3,
}

func (x Task_Type) String() string {
	if name, ok := Task_Type_name[int32(x)]; ok {
		return name
	}
	return fmt.Sprintf("Task_Type(%d)", x)
}

func ParseTask_Type(s string) (Task_Type, error) {
	if value, ok := Task_Type_value[s]; ok {
		return Task_Type(value), nil
	}
	return 0, fmt.Errorf("invalid Task_Type value: %s", s)
}

func (x Task_Type) IsValid() bool {
	_, ok := Task_Type_name[int32(x)]
	return ok
}

// Messages

// Type enum nested in message should also be integers
type Task struct {
	Id       string    `json:"id"`
	Title    string    `json:"title"`
	Status   Status    `json:"status"`
	Priority string    `json:"priority"`
	Type     Task_Type `json:"type"`
}

func NewTask() *Task {
	return &Task{}
}

func (m *Task) Validate() error {
	// Add custom validation logic here
	return nil
}

func (m *Task) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

func (m *Task) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

type TaskList struct {
	Tasks []*Task `json:"tasks"`
}

func NewTaskList() *TaskList {
	return &TaskList{}
}

func (m *TaskList) Validate() error {
	// Add custom validation logic here
	return nil
}

func (m *TaskList) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

func (m *TaskList) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// Services

type TaskServiceService interface {
	CreateTask(ctx context.Context, req *Task) (*Task, error)
	ListTasks(ctx context.Context, req *TaskList) (*TaskList, error)
}

type DefaultTaskServiceService struct{}

func (s *DefaultTaskServiceService) CreateTask(ctx context.Context, req *Task) (*Task, error) {
	// TODO: Implement CreateTask
	return &Task{}, fmt.Errorf("method CreateTask not implemented")
}

func (s *DefaultTaskServiceService) ListTasks(ctx context.Context, req *TaskList) (*TaskList, error) {
	// TODO: Implement ListTasks
	return &TaskList{}, fmt.Errorf("method ListTasks not implemented")
}

// Method name constants

const (
	TaskService_CreateTask = "TaskService_CreateTask"
	TaskService_ListTasks  = "TaskService_ListTasks"
)

var MethodMetadata = map[string]map[string]string{}

// Client

type Transport interface {
	Send(ctx context.Context, methodName string, inputData interface{}, outputType interface{}) (interface{}, error)
}

type TaskServiceClient struct {
	transport Transport
}

func NewTaskServiceClient(transport Transport) *TaskServiceClient {
	return &TaskServiceClient{transport: transport}
}

func (c *TaskServiceClient) CreateTask(ctx context.Context, req *Task) (*Task, error) {
	if metadata, exists := MethodMetadata[TaskService_CreateTask]; exists {
		ctx = context.WithValue(ctx, "method_metadata", metadata)
	}
	result, err := c.transport.Send(ctx, TaskService_CreateTask, req, (*Task)(nil))
	if err != nil {
		return nil, err
	}
	if response, ok := result.(*Task); ok {
		return response, nil
	}
	return nil, fmt.Errorf("invalid response type for CreateTask")
}

func (c *TaskServiceClient) ListTasks(ctx context.Context, req *TaskList) (*TaskList, error) {
	if metadata, exists := MethodMetadata[TaskService_ListTasks]; exists {
		ctx = context.WithValue(ctx, "method_metadata", metadata)
	}
	result, err := c.transport.Send(ctx, TaskService_ListTasks, req, (*TaskList)(nil))
	if err != nil {
		return nil, err
	}
	if response, ok := result.(*TaskList); ok {
		return response, nil
	}
	return nil, fmt.Errorf("invalid response type for ListTasks")
}
