# Code generated by protoc-gen-puregen. DO NOT EDIT.

from dataclasses import dataclass, field
from typing import Optional, List, Dict, Any
from abc import ABC, abstractmethod
import json

# Messages

# User message represents a user in the system
@dataclass
class User:
    """Generated message class for User"""
    id: int = 0
    name: str = ""
    email: str = ""
    is_active: bool = False
    tags: List[str] = field(default_factory=list)
    profile: Optional['UserProfile'] = None

    def validate(self) -> bool:
        """Validate the message fields"""
        # Add custom validation logic here
        return True

    def to_json(self) -> str:
        """Convert message to JSON string"""
        return json.dumps(self.to_dict())

    def to_dict(self) -> Dict[str, Any]:
        """Convert message to dictionary"""
        result = {}
        if self.id is not None:
            result['id'] = self.id
        if self.name is not None:
            result['name'] = self.name
        if self.email is not None:
            result['email'] = self.email
        if self.is_active is not None:
            result['isActive'] = self.is_active
        if self.tags is not None:
            result['tags'] = self.tags
        if self.profile is not None:
            result['profile'] = self.profile.to_dict() if hasattr(self.profile, 'to_dict') else self.profile
        return result

    @classmethod
    def from_json(cls, json_str: str) -> 'User':
        """Create message from JSON string"""
        data = json.loads(json_str)
        return cls.from_dict(data)

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'User':
        """Create message from dictionary"""
        kwargs = {}
        if 'id' in data:
            kwargs['id'] = data['id']
        if 'name' in data:
            kwargs['name'] = data['name']
        if 'email' in data:
            kwargs['email'] = data['email']
        if 'isActive' in data:
            kwargs['is_active'] = data['isActive']
        if 'tags' in data:
            kwargs['tags'] = data['tags']
        if 'profile' in data:
            kwargs['profile'] = UserProfile.from_dict(data['profile']) if isinstance(data['profile'], dict) else data['profile']
        return cls(**kwargs)

# UserProfile contains additional user information
@dataclass
class UserProfile:
    """Generated message class for UserProfile"""
    bio: str = ""
    avatar_url: str = ""
    created_at: int = 0

    def validate(self) -> bool:
        """Validate the message fields"""
        # Add custom validation logic here
        return True

    def to_json(self) -> str:
        """Convert message to JSON string"""
        return json.dumps(self.to_dict())

    def to_dict(self) -> Dict[str, Any]:
        """Convert message to dictionary"""
        result = {}
        if self.bio is not None:
            result['bio'] = self.bio
        if self.avatar_url is not None:
            result['avatarUrl'] = self.avatar_url
        if self.created_at is not None:
            result['createdAt'] = self.created_at
        return result

    @classmethod
    def from_json(cls, json_str: str) -> 'UserProfile':
        """Create message from JSON string"""
        data = json.loads(json_str)
        return cls.from_dict(data)

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'UserProfile':
        """Create message from dictionary"""
        kwargs = {}
        if 'bio' in data:
            kwargs['bio'] = data['bio']
        if 'avatarUrl' in data:
            kwargs['avatar_url'] = data['avatarUrl']
        if 'createdAt' in data:
            kwargs['created_at'] = data['createdAt']
        return cls(**kwargs)

# CreateUserRequest is the request for creating a user
@dataclass
class CreateUserRequest:
    """Generated message class for CreateUserRequest"""
    name: str = ""
    email: str = ""
    profile: Optional['UserProfile'] = None

    def validate(self) -> bool:
        """Validate the message fields"""
        # Add custom validation logic here
        return True

    def to_json(self) -> str:
        """Convert message to JSON string"""
        return json.dumps(self.to_dict())

    def to_dict(self) -> Dict[str, Any]:
        """Convert message to dictionary"""
        result = {}
        if self.name is not None:
            result['name'] = self.name
        if self.email is not None:
            result['email'] = self.email
        if self.profile is not None:
            result['profile'] = self.profile.to_dict() if hasattr(self.profile, 'to_dict') else self.profile
        return result

    @classmethod
    def from_json(cls, json_str: str) -> 'CreateUserRequest':
        """Create message from JSON string"""
        data = json.loads(json_str)
        return cls.from_dict(data)

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'CreateUserRequest':
        """Create message from dictionary"""
        kwargs = {}
        if 'name' in data:
            kwargs['name'] = data['name']
        if 'email' in data:
            kwargs['email'] = data['email']
        if 'profile' in data:
            kwargs['profile'] = UserProfile.from_dict(data['profile']) if isinstance(data['profile'], dict) else data['profile']
        return cls(**kwargs)

# CreateUserResponse is the response for creating a user
@dataclass
class CreateUserResponse:
    """Generated message class for CreateUserResponse"""
    user: Optional['User'] = None
    success: bool = False
    message: str = ""

    def validate(self) -> bool:
        """Validate the message fields"""
        # Add custom validation logic here
        return True

    def to_json(self) -> str:
        """Convert message to JSON string"""
        return json.dumps(self.to_dict())

    def to_dict(self) -> Dict[str, Any]:
        """Convert message to dictionary"""
        result = {}
        if self.user is not None:
            result['user'] = self.user.to_dict() if hasattr(self.user, 'to_dict') else self.user
        if self.success is not None:
            result['success'] = self.success
        if self.message is not None:
            result['message'] = self.message
        return result

    @classmethod
    def from_json(cls, json_str: str) -> 'CreateUserResponse':
        """Create message from JSON string"""
        data = json.loads(json_str)
        return cls.from_dict(data)

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'CreateUserResponse':
        """Create message from dictionary"""
        kwargs = {}
        if 'user' in data:
            kwargs['user'] = User.from_dict(data['user']) if isinstance(data['user'], dict) else data['user']
        if 'success' in data:
            kwargs['success'] = data['success']
        if 'message' in data:
            kwargs['message'] = data['message']
        return cls(**kwargs)

# GetUserRequest is the request for getting a user
@dataclass
class GetUserRequest:
    """Generated message class for GetUserRequest"""
    id: int = 0

    def validate(self) -> bool:
        """Validate the message fields"""
        # Add custom validation logic here
        return True

    def to_json(self) -> str:
        """Convert message to JSON string"""
        return json.dumps(self.to_dict())

    def to_dict(self) -> Dict[str, Any]:
        """Convert message to dictionary"""
        result = {}
        if self.id is not None:
            result['id'] = self.id
        return result

    @classmethod
    def from_json(cls, json_str: str) -> 'GetUserRequest':
        """Create message from JSON string"""
        data = json.loads(json_str)
        return cls.from_dict(data)

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'GetUserRequest':
        """Create message from dictionary"""
        kwargs = {}
        if 'id' in data:
            kwargs['id'] = data['id']
        return cls(**kwargs)

# GetUserResponse is the response for getting a user
@dataclass
class GetUserResponse:
    """Generated message class for GetUserResponse"""
    user: Optional['User'] = None
    found: bool = False

    def validate(self) -> bool:
        """Validate the message fields"""
        # Add custom validation logic here
        return True

    def to_json(self) -> str:
        """Convert message to JSON string"""
        return json.dumps(self.to_dict())

    def to_dict(self) -> Dict[str, Any]:
        """Convert message to dictionary"""
        result = {}
        if self.user is not None:
            result['user'] = self.user.to_dict() if hasattr(self.user, 'to_dict') else self.user
        if self.found is not None:
            result['found'] = self.found
        return result

    @classmethod
    def from_json(cls, json_str: str) -> 'GetUserResponse':
        """Create message from JSON string"""
        data = json.loads(json_str)
        return cls.from_dict(data)

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'GetUserResponse':
        """Create message from dictionary"""
        kwargs = {}
        if 'user' in data:
            kwargs['user'] = User.from_dict(data['user']) if isinstance(data['user'], dict) else data['user']
        if 'found' in data:
            kwargs['found'] = data['found']
        return cls(**kwargs)

# Services

# UserService provides operations for managing users
class UserServiceService(ABC):
    """Abstract service interface for UserService"""

    # CreateUser creates a new user
    @abstractmethod
    def create_user(self, ctx: Dict[str, Any], request: CreateUserRequest) -> CreateUserResponse:
        """CreateUser method"""
        pass

    """
    GetUser retrieves a user by ID
    This method retrieves a user by their unique ID.
    It returns the user details if found, otherwise indicates not found.
    """
    @abstractmethod
    def get_user(self, ctx: Dict[str, Any], request: GetUserRequest) -> GetUserResponse:
        """GetUser method"""
        pass

class DefaultUserServiceService(UserServiceService):
    """Default implementation of UserServiceService"""

    # CreateUser creates a new user
    def create_user(self, ctx: Dict[str, Any], request: CreateUserRequest) -> CreateUserResponse:
        """CreateUser method implementation"""
        # TODO: Implement create_user
        raise NotImplementedError("Method create_user not implemented")

    """
    GetUser retrieves a user by ID
    This method retrieves a user by their unique ID.
    It returns the user details if found, otherwise indicates not found.
    """
    def get_user(self, ctx: Dict[str, Any], request: GetUserRequest) -> GetUserResponse:
        """GetUser method implementation"""
        # TODO: Implement get_user
        raise NotImplementedError("Method get_user not implemented")

# Method name constants

class UserServiceMethods:
    """Method name constants for UserService"""
    UserService_CreateUser = "UserService_CreateUser"
    UserService_GetUser = "UserService_GetUser"

    METHOD_METADATA = {
        UserService_CreateUser: {
            "method": "POST",
            "path": "/users",
        },
        UserService_GetUser: {
            "method": "GET",
            "path": "/users/{id}",
        },
    }

# Client

class Transport(ABC):
    """Abstract transport interface for client communication"""

    @abstractmethod
    def send(self, ctx: Dict[str, Any], method_name: str, input_data: Any, output_type: type) -> Any:
        """Send request and return response"""
        pass

class UserServiceClient:
    """Client for UserService service"""

    def __init__(self, transport: Transport):
        self.transport = transport

    def create_user(self, ctx: Dict[str, Any], request: CreateUserRequest) -> CreateUserResponse:
        """CreateUser client method"""
        enhanced_ctx = ctx.copy() if ctx else {}
        method_metadata = UserServiceMethods.METHOD_METADATA.get(UserServiceMethods.UserService_CreateUser, {})
        enhanced_ctx['method_metadata'] = method_metadata
        result = self.transport.send(enhanced_ctx, UserServiceMethods.UserService_CreateUser, request, CreateUserResponse)
        if isinstance(result, CreateUserResponse):
            return result
        if isinstance(result, dict):
            return CreateUserResponse.from_dict(result)
        raise ValueError(f"Invalid response type for create_user: {type(result)}")

    def get_user(self, ctx: Dict[str, Any], request: GetUserRequest) -> GetUserResponse:
        """GetUser client method"""
        enhanced_ctx = ctx.copy() if ctx else {}
        method_metadata = UserServiceMethods.METHOD_METADATA.get(UserServiceMethods.UserService_GetUser, {})
        enhanced_ctx['method_metadata'] = method_metadata
        result = self.transport.send(enhanced_ctx, UserServiceMethods.UserService_GetUser, request, GetUserResponse)
        if isinstance(result, GetUserResponse):
            return result
        if isinstance(result, dict):
            return GetUserResponse.from_dict(result)
        raise ValueError(f"Invalid response type for get_user: {type(result)}")

