# Code generated by protoc-gen-puregen. DO NOT EDIT.

from dataclasses import dataclass, field
from typing import Optional, List, Dict, Any
from abc import ABC, abstractmethod
import json
from .puregen_transport import PuregenTransport
from puregen.examples.groups.principal import Principal

# Imported Messages (redefined locally)

@dataclass
class Error:
    """Generated message class for Error"""
    # Error code
    code: int = 0
    # Human-readable error message
    message: str = ""
    # Additional details about the error
    details: str = ""

    def validate(self) -> bool:
        """Validate the message fields"""
        # Add custom validation logic here
        return True

    def to_json(self) -> str:
        """Convert message to JSON string"""
        return json.dumps(self.to_dict())

    def to_dict(self) -> Dict[str, Any]:
        """Convert message to dictionary"""
        result = {}
        if self.code is not None:
            result['code'] = self.code
        if self.message is not None:
            result['message'] = self.message
        if self.details is not None:
            result['details'] = self.details
        return result

    @classmethod
    def from_json(cls, json_str: str) -> 'Error':
        """Create message from JSON string"""
        data = json.loads(json_str)
        return cls.from_dict(data)

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'Error':
        """Create message from dictionary"""
        kwargs = {}
        if 'code' in data:
            kwargs['code'] = data['code']
        if 'message' in data:
            kwargs['message'] = data['message']
        if 'details' in data:
            kwargs['details'] = data['details']
        return cls(**kwargs)

# Messages

# Group represents a group entity
@dataclass
class Group:
    """Generated message class for Group"""
    id: str = ""
    name: str = ""
    description: str = ""
    created_at: int = 0

    def validate(self) -> bool:
        """Validate the message fields"""
        # Add custom validation logic here
        return True

    def to_json(self) -> str:
        """Convert message to JSON string"""
        return json.dumps(self.to_dict())

    def to_dict(self) -> Dict[str, Any]:
        """Convert message to dictionary"""
        result = {}
        if self.id is not None:
            result['id'] = self.id
        if self.name is not None:
            result['name'] = self.name
        if self.description is not None:
            result['description'] = self.description
        if self.created_at is not None:
            result['createdAt'] = self.created_at
        return result

    @classmethod
    def from_json(cls, json_str: str) -> 'Group':
        """Create message from JSON string"""
        data = json.loads(json_str)
        return cls.from_dict(data)

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'Group':
        """Create message from dictionary"""
        kwargs = {}
        if 'id' in data:
            kwargs['id'] = data['id']
        if 'name' in data:
            kwargs['name'] = data['name']
        if 'description' in data:
            kwargs['description'] = data['description']
        if 'createdAt' in data:
            kwargs['created_at'] = data['createdAt']
        return cls(**kwargs)

# CreateGroupRequest is the request for creating a group
@dataclass
class CreateGroupRequest:
    """Generated message class for CreateGroupRequest"""
    name: str = ""
    description: str = ""
    # Principal who owns the group
    owner: Optional['Principal'] = None

    def validate(self) -> bool:
        """Validate the message fields"""
        # Add custom validation logic here
        return True

    def to_json(self) -> str:
        """Convert message to JSON string"""
        return json.dumps(self.to_dict())

    def to_dict(self) -> Dict[str, Any]:
        """Convert message to dictionary"""
        result = {}
        if self.name is not None:
            result['name'] = self.name
        if self.description is not None:
            result['description'] = self.description
        if self.owner is not None:
            result['owner'] = self.owner.to_dict() if hasattr(self.owner, 'to_dict') else self.owner
        return result

    @classmethod
    def from_json(cls, json_str: str) -> 'CreateGroupRequest':
        """Create message from JSON string"""
        data = json.loads(json_str)
        return cls.from_dict(data)

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'CreateGroupRequest':
        """Create message from dictionary"""
        kwargs = {}
        if 'name' in data:
            kwargs['name'] = data['name']
        if 'description' in data:
            kwargs['description'] = data['description']
        if 'owner' in data:
            kwargs['owner'] = Principal.from_dict(data['owner']) if isinstance(data['owner'], dict) else data['owner']
        return cls(**kwargs)

# CreateGroupResponse is the response for creating a group
@dataclass
class CreateGroupResponse:
    """Generated message class for CreateGroupResponse"""
    group: Optional['Group'] = None
    # Error details if creation fails
    error: Optional['Error'] = None

    def validate(self) -> bool:
        """Validate the message fields"""
        # Add custom validation logic here
        return True

    def to_json(self) -> str:
        """Convert message to JSON string"""
        return json.dumps(self.to_dict())

    def to_dict(self) -> Dict[str, Any]:
        """Convert message to dictionary"""
        result = {}
        if self.group is not None:
            result['group'] = self.group.to_dict() if hasattr(self.group, 'to_dict') else self.group
        if self.error is not None:
            result['error'] = self.error.to_dict() if hasattr(self.error, 'to_dict') else self.error
        return result

    @classmethod
    def from_json(cls, json_str: str) -> 'CreateGroupResponse':
        """Create message from JSON string"""
        data = json.loads(json_str)
        return cls.from_dict(data)

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'CreateGroupResponse':
        """Create message from dictionary"""
        kwargs = {}
        if 'group' in data:
            kwargs['group'] = Group.from_dict(data['group']) if isinstance(data['group'], dict) else data['group']
        if 'error' in data:
            kwargs['error'] = Error.from_dict(data['error']) if isinstance(data['error'], dict) else data['error']
        return cls(**kwargs)

# ListGroupsRequest is the request for listing groups
@dataclass
class ListGroupsRequest:
    """Generated message class for ListGroupsRequest"""
    page_size: int = 0
    page_token: str = ""

    def validate(self) -> bool:
        """Validate the message fields"""
        # Add custom validation logic here
        return True

    def to_json(self) -> str:
        """Convert message to JSON string"""
        return json.dumps(self.to_dict())

    def to_dict(self) -> Dict[str, Any]:
        """Convert message to dictionary"""
        result = {}
        if self.page_size is not None:
            result['pageSize'] = self.page_size
        if self.page_token is not None:
            result['pageToken'] = self.page_token
        return result

    @classmethod
    def from_json(cls, json_str: str) -> 'ListGroupsRequest':
        """Create message from JSON string"""
        data = json.loads(json_str)
        return cls.from_dict(data)

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'ListGroupsRequest':
        """Create message from dictionary"""
        kwargs = {}
        if 'pageSize' in data:
            kwargs['page_size'] = data['pageSize']
        if 'pageToken' in data:
            kwargs['page_token'] = data['pageToken']
        return cls(**kwargs)

# ListGroupsResponse is the response for listing groups
@dataclass
class ListGroupsResponse:
    """Generated message class for ListGroupsResponse"""
    groups: List['Group'] = field(default_factory=list)
    next_page_token: str = ""

    def validate(self) -> bool:
        """Validate the message fields"""
        # Add custom validation logic here
        return True

    def to_json(self) -> str:
        """Convert message to JSON string"""
        return json.dumps(self.to_dict())

    def to_dict(self) -> Dict[str, Any]:
        """Convert message to dictionary"""
        result = {}
        if self.groups is not None:
            result['groups'] = [item.to_dict() if hasattr(item, 'to_dict') else item for item in self.groups]
        if self.next_page_token is not None:
            result['nextPageToken'] = self.next_page_token
        return result

    @classmethod
    def from_json(cls, json_str: str) -> 'ListGroupsResponse':
        """Create message from JSON string"""
        data = json.loads(json_str)
        return cls.from_dict(data)

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'ListGroupsResponse':
        """Create message from dictionary"""
        kwargs = {}
        if 'groups' in data:
            kwargs['groups'] = [Group.from_dict(item) if isinstance(item, dict) else item for item in data['groups']]
        if 'nextPageToken' in data:
            kwargs['next_page_token'] = data['nextPageToken']
        return cls(**kwargs)

# Services

# GroupService provides operations on groups
class GroupServiceService(ABC):
    """Abstract service interface for GroupService"""

    # CreateGroup creates a new group
    @abstractmethod
    def create_group(self, ctx: Dict[str, Any], request: CreateGroupRequest) -> CreateGroupResponse:
        """CreateGroup method"""
        pass

    # ListGroups lists all groups with pagination
    @abstractmethod
    def list_groups(self, ctx: Dict[str, Any], request: ListGroupsRequest) -> ListGroupsResponse:
        """ListGroups method"""
        pass

class DefaultGroupServiceService(GroupServiceService):
    """Default implementation of GroupServiceService"""

    # CreateGroup creates a new group
    def create_group(self, ctx: Dict[str, Any], request: CreateGroupRequest) -> CreateGroupResponse:
        """CreateGroup method implementation"""
        # TODO: Implement create_group
        raise NotImplementedError("Method create_group not implemented")

    # ListGroups lists all groups with pagination
    def list_groups(self, ctx: Dict[str, Any], request: ListGroupsRequest) -> ListGroupsResponse:
        """ListGroups method implementation"""
        # TODO: Implement list_groups
        raise NotImplementedError("Method list_groups not implemented")

# Method name constants

class GroupServiceMethods:
    """Method name constants for GroupService"""
    GroupService_CreateGroup = "GroupService_CreateGroup"
    GroupService_ListGroups = "GroupService_ListGroups"

    METHOD_METADATA = {
    }

# Client

class GroupServiceClient:
    """Client for GroupService service"""

    def __init__(self, transport: PuregenTransport):
        self.transport = transport

    def create_group(self, ctx: Dict[str, Any], request: CreateGroupRequest) -> CreateGroupResponse:
        """CreateGroup client method"""
        enhanced_ctx = ctx.copy() if ctx else {}
        method_metadata = GroupServiceMethods.METHOD_METADATA.get(GroupServiceMethods.GroupService_CreateGroup, {})
        enhanced_ctx['method_metadata'] = method_metadata
        result = self.transport.send(enhanced_ctx, GroupServiceMethods.GroupService_CreateGroup, request, CreateGroupResponse)
        if isinstance(result, CreateGroupResponse):
            return result
        if isinstance(result, dict):
            return CreateGroupResponse.from_dict(result)
        raise ValueError(f"Invalid response type for create_group: {type(result)}")

    def list_groups(self, ctx: Dict[str, Any], request: ListGroupsRequest) -> ListGroupsResponse:
        """ListGroups client method"""
        enhanced_ctx = ctx.copy() if ctx else {}
        method_metadata = GroupServiceMethods.METHOD_METADATA.get(GroupServiceMethods.GroupService_ListGroups, {})
        enhanced_ctx['method_metadata'] = method_metadata
        result = self.transport.send(enhanced_ctx, GroupServiceMethods.GroupService_ListGroups, request, ListGroupsResponse)
        if isinstance(result, ListGroupsResponse):
            return result
        if isinstance(result, dict):
            return ListGroupsResponse.from_dict(result)
        raise ValueError(f"Invalid response type for list_groups: {type(result)}")

