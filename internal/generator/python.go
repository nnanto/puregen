package generator

import (
	"path/filepath"
	"sort"
	"strconv"
	"strings"

	"google.golang.org/protobuf/compiler/protogen"
)

// formatPythonComment formats a comment for Python code
func formatPythonComment(comments protogen.CommentSet) []string {
	var result []string

	// Use leading comments if available, otherwise trailing
	comment := comments.Leading
	if comment == "" && comments.Trailing != "" {
		comment = comments.Trailing
	}

	if comment == "" {
		return result
	}

	// Split by lines and format each line
	lines := strings.Split(strings.TrimSpace(string(comment)), "\n")

	// If single line, use # style
	if len(lines) == 1 {
		result = append(result, "# "+lines[0])
		return result
	}

	// Multi-line comment with """ """ style
	result = append(result, "\"\"\"")
	for _, line := range lines {
		line = strings.TrimSpace(line)
		if line == "" {
			result = append(result, "")
		} else {
			result = append(result, line)
		}
	}
	result = append(result, "\"\"\"")

	return result
}

// writePythonComment writes formatted comments to the generator
func writePythonComment(g *protogen.GeneratedFile, comments protogen.CommentSet) {
	commentLines := formatPythonComment(comments)
	for _, line := range commentLines {
		g.P(line)
	}
}

// Track created package directories to avoid duplicates
var createdPythonPackages = make(map[string]bool)





// GeneratePythonFile generates Python code for the given protobuf file
func GeneratePythonFile(gen *protogen.Plugin, file *protogen.File, commonNamespace string) {
	if len(file.Messages) == 0 && len(file.Services) == 0 {
		return
	}

	// Generate global transport if namespace is provided and we have services
	if commonNamespace != "" && len(file.Services) > 0 {
		generateGlobalTransport(gen, commonNamespace)
	}

	// Get Python module name and create package structure
	moduleName := getPythonModuleName(file)

	// Create package directories with __init__.py files
	createPythonPackageStructure(gen, moduleName)

	// Create the main module file in the package directory
	baseFilename := filepath.Base(strings.ReplaceAll(*file.Proto.Name, ".proto", ""))
	filename := strings.ReplaceAll(moduleName, ".", "/") + "/" + baseFilename + ".py"
	g := gen.NewGeneratedFile(filename, "")

	// Generate file header
	g.P("# Code generated by protoc-gen-puregen. DO NOT EDIT.")
	g.P()
	g.P("from dataclasses import dataclass, field")
	g.P("from typing import Optional, List, Dict, Any")
	g.P("from abc import ABC, abstractmethod")
	g.P("import json")

	// Check if we need IntEnum import
	enumsForImport := collectAllEnums(file)
	needsIntEnum := false
	for _, enum := range enumsForImport {
		directive := parsePuregenDirective(enum.Comments)
		if directive != nil && directive.EnumType == "int" {
			needsIntEnum = true
			break
		}
	}
	if needsIntEnum {
		g.P("from enum import IntEnum")
	}

	// Import global transport if namespace is provided and we have services
	if commonNamespace != "" && len(file.Services) > 0 {
		g.P("from ", commonNamespace, " import Transport")
	}

	// Collect and generate imports for same package messages
	samePackageMessages := collectSamePackageMessages(file)
	if len(samePackageMessages) > 0 {
		for _, message := range samePackageMessages {
			// Get the module name for the message (based on its file)
			msgFilename := strings.TrimSuffix(filepath.Base(message.Desc.ParentFile().Path()), ".proto")
			// Use full package path with dots for import
			packagePath := getPythonImportModuleName(file)
			g.P("from ", packagePath, ".", msgFilename, " import ", message.GoIdent.GoName)
		}
	}
	g.P()

	// Collect and generate imported messages first
	importedMessages := collectImportedMessages(file)
	if len(importedMessages) > 0 {
		g.P("# Imported Messages (redefined locally)")
		g.P()
		for _, message := range importedMessages {
			generatePythonMessage(g, message)
		}
	}

	// Generate all enums (including nested and unreferenced)
	allEnums := collectAllEnums(file)
	if len(allEnums) > 0 {
		g.P("# Enums")
		g.P()
	}
	for _, enum := range allEnums {
		generatePythonEnum(g, enum)
	}

	// Generate messages
	if len(file.Messages) > 0 {
		g.P("# Messages")
		g.P()
	}
	for _, message := range file.Messages {
		generatePythonMessage(g, message)
	}

	// Generate services
	if len(file.Services) > 0 {
		g.P("# Services")
		g.P()
	}
	for _, service := range file.Services {
		generatePythonService(g, service)
	}

	// Generate method name constants
	if len(file.Services) > 0 {
		g.P("# Method name constants")
		g.P()
		for _, service := range file.Services {
			generatePythonMethodConstants(g, service)
		}
	}

	if len(file.Services) > 0 {
		g.P("# Client")
		g.P()
	}
	for _, service := range file.Services {
		generatePythonClient(g, service, commonNamespace)
	}
}

func generatePythonMethodConstants(g *protogen.GeneratedFile, service *protogen.Service) {
	serviceName := service.GoName

	g.P("class ", serviceName, "Methods:")
	g.P("    \"\"\"Method name constants for ", serviceName, "\"\"\"")

	for _, method := range service.Methods {
		constName := serviceName + "_" + method.GoName
		g.P("    ", constName, " = \"", constName, "\"")
	}
	g.P()

	// Generate method metadata dictionary
	g.P("    METHOD_METADATA = {")
	for _, method := range service.Methods {
		constName := serviceName + "_" + method.GoName
		metadata := parseMethodMetadata(method.Comments)
		if metadata != nil {
			g.P("        ", constName, ": {")

			// Sort keys for consistent output
			var keys []string
			for key := range metadata {
				keys = append(keys, key)
			}
			sort.Strings(keys)

			for _, key := range keys {
				value := metadata[key]
				g.P("            \"", key, "\": \"", value, "\",")
			}
			g.P("        },")
		}
	}
	g.P("    }")
	g.P()
}

func generatePythonEnum(g *protogen.GeneratedFile, enum *protogen.Enum) {
	enumName := enum.GoIdent.GoName

	// Parse puregen directive to determine enum type
	directive := parsePuregenDirective(enum.Comments)
	useStringConstants := true // Default to string constants
	
	if directive != nil && directive.EnumType == "int" {
		useStringConstants = false
	}

	// Generate enum comment
	writePythonComment(g, enum.Comments)

	if useStringConstants {
		// Generate string constants class
		g.P("class ", enumName, ":")
		g.P("    \"\"\"", enumName, " enum values as string constants\"\"\"")
		
		for _, value := range enum.Values {
			valueName := strings.ToUpper(string(value.Desc.Name()))
			g.P("    ", valueName, " = \"", value.Desc.Name(), "\"")
		}
		g.P()

		// Generate list of all values for validation
		g.P("    VALUES = [")
		for _, value := range enum.Values {
			valueName := strings.ToUpper(string(value.Desc.Name()))
			g.P("        ", valueName, ",")
		}
		g.P("    ]")
		g.P()

		// Generate validation method
		g.P("    @classmethod")
		g.P("    def is_valid(cls, value: str) -> bool:")
		g.P("        \"\"\"Check if value is a valid ", enumName, "\"\"\"")
		g.P("        return value in cls.VALUES")
		g.P()
	} else {
		// Generate IntEnum class
		g.P("class ", enumName, "(IntEnum):")
		g.P("    \"\"\"", enumName, " enum values as integers\"\"\"")
		
		for _, value := range enum.Values {
			valueName := strings.ToUpper(string(value.Desc.Name()))
			g.P("    ", valueName, " = ", value.Desc.Number())
		}
		g.P()

		// Generate validation method
		g.P("    @classmethod")
		g.P("    def is_valid(cls, value: int) -> bool:")
		g.P("        \"\"\"Check if value is a valid ", enumName, "\"\"\"")
		g.P("        return value in [item.value for item in cls]")
		g.P()
	}

	// Generate enum metadata if available
	enumMetadata := parseEnumMetadata(enum.Comments)
	if enumMetadata != nil {
		g.P("# Metadata for ", enumName)
		g.P(enumName, "Metadata = {")
		// Sort keys for consistent output
		var keys []string
		for key := range enumMetadata {
			keys = append(keys, key)
		}
		sort.Strings(keys)

		for _, key := range keys {
			value := enumMetadata[key]
			g.P("    \"", key, "\": \"", value, "\",")
		}
		g.P("}")
		g.P()
	}
}

func generatePythonMessage(g *protogen.GeneratedFile, msg *protogen.Message) {
	// Generate message comment
	writePythonComment(g, msg.Comments)

	// Generate dataclass
	g.P("@dataclass")
	g.P("class ", msg.GoIdent.GoName, ":")
	g.P("    \"\"\"Generated message class for ", msg.GoIdent.GoName, "\"\"\"")

	// Generate fields with default values
	if len(msg.Fields) == 0 {
		g.P("    pass")
	} else {
		for _, field := range msg.Fields {
			// Generate field comment
			if commentLines := formatPythonComment(field.Comments); len(commentLines) > 0 {
				for _, line := range commentLines {
					g.P("    ", line)
				}
			}

			fieldType := getPythonFieldType(field)
			fieldName := getPythonFieldName(field.GoName)
			defaultValue := getPythonDefaultValue(field)
			g.P("    ", fieldName, ": ", fieldType, " = ", defaultValue)
		}
	}
	g.P()

	// Generate validation method
	g.P("    def validate(self) -> bool:")
	g.P("        \"\"\"Validate the message fields\"\"\"")
	g.P("        # Add custom validation logic here")
	g.P("        return True")
	g.P()

	// Generate JSON serialization methods
	g.P("    def to_json(self) -> str:")
	g.P("        \"\"\"Convert message to JSON string\"\"\"")
	g.P("        return json.dumps(self.to_dict())")
	g.P()

	g.P("    def to_dict(self) -> Dict[str, Any]:")
	g.P("        \"\"\"Convert message to dictionary\"\"\"")
	g.P("        result = {}")
	for _, field := range msg.Fields {
		fieldName := getPythonFieldName(field.GoName)
		jsonName := field.Desc.JSONName()
		g.P("        if self.", fieldName, " is not None:")
		if field.Desc.IsList() {
			if field.Message != nil {
				g.P("            result['", jsonName, "'] = [item.to_dict() if hasattr(item, 'to_dict') else item for item in self.", fieldName, "]")
			} else {
				g.P("            result['", jsonName, "'] = self.", fieldName)
			}
		} else if field.Message != nil {
			g.P("            result['", jsonName, "'] = self.", fieldName, ".to_dict() if hasattr(self.", fieldName, ", 'to_dict') else self.", fieldName)
		} else {
			g.P("            result['", jsonName, "'] = self.", fieldName)
		}
	}
	g.P("        return result")
	g.P()

	g.P("    @classmethod")
	g.P("    def from_json(cls, json_str: str) -> '", msg.GoIdent.GoName, "':")
	g.P("        \"\"\"Create message from JSON string\"\"\"")
	g.P("        data = json.loads(json_str)")
	g.P("        return cls.from_dict(data)")
	g.P()

	g.P("    @classmethod")
	g.P("    def from_dict(cls, data: Dict[str, Any]) -> '", msg.GoIdent.GoName, "':")
	g.P("        \"\"\"Create message from dictionary\"\"\"")
	g.P("        kwargs = {}")
	for _, field := range msg.Fields {
		fieldName := getPythonFieldName(field.GoName)
		jsonName := field.Desc.JSONName()
		if field.Desc.IsList() {
			if field.Message != nil {
				g.P("        if '", jsonName, "' in data:")
				g.P("            kwargs['", fieldName, "'] = [", field.Message.GoIdent.GoName, ".from_dict(item) if isinstance(item, dict) else item for item in data['", jsonName, "']]")
			} else {
				g.P("        if '", jsonName, "' in data:")
				g.P("            kwargs['", fieldName, "'] = data['", jsonName, "']")
			}
		} else if field.Message != nil {
			g.P("        if '", jsonName, "' in data:")
			g.P("            kwargs['", fieldName, "'] = ", field.Message.GoIdent.GoName, ".from_dict(data['", jsonName, "']) if isinstance(data['", jsonName, "'], dict) else data['", jsonName, "']")
		} else {
			g.P("        if '", jsonName, "' in data:")
			g.P("            kwargs['", fieldName, "'] = data['", jsonName, "']")
		}
	}
	g.P("        return cls(**kwargs)")
	g.P()

	// Generate nested messages
	for _, nested := range msg.Messages {
		generatePythonMessage(g, nested)
	}

	// Generate message metadata if available
	messageMetadata := parseMessageMetadata(msg.Comments)
	if messageMetadata != nil {
		g.P("# Metadata for ", msg.GoIdent.GoName)
		g.P(msg.GoIdent.GoName, "Metadata = {")
		// Sort keys for consistent output
		var keys []string
		for key := range messageMetadata {
			keys = append(keys, key)
		}
		sort.Strings(keys)

		for _, key := range keys {
			value := messageMetadata[key]
			g.P("    \"", key, "\": \"", value, "\",")
		}
		g.P("}")
		g.P()
	}

	// Generate field constants and metadata if any fields have metadata
	hasFieldMetadata := false
	for _, field := range msg.Fields {
		fieldMetadata := parseFieldMetadata(field.Comments)
		if fieldMetadata != nil {
			hasFieldMetadata = true
			break
		}
	}

	if hasFieldMetadata {
		// Generate field constants
		g.P("# Field name constants for ", msg.GoIdent.GoName)
		for _, field := range msg.Fields {
			fieldMetadata := parseFieldMetadata(field.Comments)
			if fieldMetadata != nil {
				constName := msg.GoIdent.GoName + "_" + field.GoName + "_FIELD"
				constValue := msg.GoIdent.GoName + "_" + field.GoName
				g.P(constName, " = \"", constValue, "\"")
			}
		}
		g.P()

		// Generate MessageField metadata map
		g.P("# MessageField metadata for ", msg.GoIdent.GoName)
		g.P(msg.GoIdent.GoName, "FieldMetadata = {")
		for _, field := range msg.Fields {
			fieldMetadata := parseFieldMetadata(field.Comments)
			if fieldMetadata != nil {
				constName := msg.GoIdent.GoName + "_" + field.GoName + "_FIELD"
				g.P("    ", constName, ": {")

				// Sort keys for consistent output
				var keys []string
				for key := range fieldMetadata {
					keys = append(keys, key)
				}
				sort.Strings(keys)

				for _, key := range keys {
					value := fieldMetadata[key]
					g.P("        \"", key, "\": \"", value, "\",")
				}
				g.P("    },")
			}
		}
		g.P("}")
		g.P()
	}
}

func generatePythonService(g *protogen.GeneratedFile, service *protogen.Service) {
	serviceName := service.GoName

	// Generate service comment
	writePythonComment(g, service.Comments)

	// Generate abstract service interface
	g.P("class ", serviceName, "Service(ABC):")
	g.P("    \"\"\"Abstract service interface for ", serviceName, "\"\"\"")
	g.P()

	for _, method := range service.Methods {
		// Generate method comment
		if commentLines := formatPythonComment(method.Comments); len(commentLines) > 0 {
			for _, line := range commentLines {
				g.P("    ", line)
			}
		}

		inputType := method.Input.GoIdent.GoName
		outputType := method.Output.GoIdent.GoName
		methodName := getPythonMethodName(method.GoName)

		g.P("    @abstractmethod")
		g.P("    def ", methodName, "(self, ctx: Dict[str, Any], request: ", inputType, ") -> ", outputType, ":")
		g.P("        \"\"\"", method.GoName, " method\"\"\"")
		g.P("        pass")
		g.P()
	}

	// Generate default implementation
	g.P("class Default", serviceName, "Service(", serviceName, "Service):")
	g.P("    \"\"\"Default implementation of ", serviceName, "Service\"\"\"")
	g.P()

	for _, method := range service.Methods {
		// Generate method comment
		if commentLines := formatPythonComment(method.Comments); len(commentLines) > 0 {
			for _, line := range commentLines {
				g.P("    ", line)
			}
		}

		inputType := method.Input.GoIdent.GoName
		outputType := method.Output.GoIdent.GoName
		methodName := getPythonMethodName(method.GoName)

		g.P("    def ", methodName, "(self, ctx: Dict[str, Any], request: ", inputType, ") -> ", outputType, ":")
		g.P("        \"\"\"", method.GoName, " method implementation\"\"\"")
		g.P("        # TODO: Implement ", methodName)
		g.P("        raise NotImplementedError(\"Method ", methodName, " not implemented\")")
		g.P()
	}
}

func generatePythonClient(g *protogen.GeneratedFile, service *protogen.Service, commonNamespace string) {
	serviceName := service.GoName

	// Only generate Transport interface if no global namespace is provided
	if commonNamespace == "" {
		// Generate Transport interface
		g.P("class Transport(ABC):")
		g.P("    \"\"\"Abstract transport interface for client communication\"\"\"")
		g.P()
		g.P("    @abstractmethod")
		g.P("    def send(self, ctx: Dict[str, Any], method_name: str, input_data: Any, output_type: type) -> Any:")
		g.P("        \"\"\"Send request and return response\"\"\"")
		g.P("        pass")
		g.P()
	}

	// Generate client class
	g.P("class ", serviceName, "Client:")
	g.P("    \"\"\"Client for ", serviceName, " service\"\"\"")
	g.P()
	g.P("    def __init__(self, transport: Transport):")
	g.P("        self.transport = transport")
	g.P()

	// Generate client methods
	for _, method := range service.Methods {
		inputType := method.Input.GoIdent.GoName
		outputType := method.Output.GoIdent.GoName
		methodName := getPythonMethodName(method.GoName)
		constName := serviceName + "Methods." + serviceName + "_" + method.GoName

		g.P("    def ", methodName, "(self, ctx: Dict[str, Any], request: ", inputType, ") -> ", outputType, ":")
		g.P("        \"\"\"", method.GoName, " client method\"\"\"")
		g.P("        enhanced_ctx = ctx.copy() if ctx else {}")
		g.P("        method_metadata = ", serviceName, "Methods.METHOD_METADATA.get(", constName, ", {})")
		g.P("        enhanced_ctx['method_metadata'] = method_metadata")
		g.P("        result = self.transport.send(enhanced_ctx, ", constName, ", request, ", outputType, ")")
		g.P("        if isinstance(result, ", outputType, "):")
		g.P("            return result")
		g.P("        if isinstance(result, dict):")
		g.P("            return ", outputType, ".from_dict(result)")
		g.P("        raise ValueError(f\"Invalid response type for ", methodName, ": {type(result)}\")")
		g.P()
	}
}

// createPythonPackageStructure creates directories and __init__.py files for the package hierarchy
func createPythonPackageStructure(gen *protogen.Plugin, moduleName string) {
	// For single level package, create __init__.py in the module directory
	if !strings.Contains(moduleName, ".") {
		initFile := moduleName + "/__init__.py"
		if !createdPythonPackages[initFile] {
			// Check if __init__.py already exists, if so, ignore it
			if fileExists(gen, initFile) {
				createdPythonPackages[initFile] = true
				return
			}
			initGen := gen.NewGeneratedFile(initFile, "")
			initGen.P("# Package initialization file")
			initGen.P("# Generated by protoc-gen-puregen")
			createdPythonPackages[initFile] = true
		}
		return
	}

	// For multi-level package, only create __init__.py in the final directory
	parts := strings.Split(moduleName, ".")
	finalPath := strings.Join(parts, "/")
	initFile := finalPath + "/__init__.py"

	if !createdPythonPackages[initFile] {
		// Check if __init__.py already exists, if so, ignore it
		if fileExists(gen, initFile) {
			createdPythonPackages[initFile] = true
			return
		}
		initGen := gen.NewGeneratedFile(initFile, "")
		initGen.P("# Package initialization file")
		initGen.P("# Generated by protoc-gen-puregen")
		createdPythonPackages[initFile] = true
	}
}

func getPythonModuleName(file *protogen.File) string {
	// Convert proto package to Python module name
	pkg := string(file.Desc.Package())
	if pkg == "" {
		// Use filename without extension
		return strings.TrimSuffix(filepath.Base(file.Desc.Path()), ".proto")
	}

	// Replace dots with slashes for Python package structure
	pkg = strings.ReplaceAll(pkg, ".", "/")
	// Ensure the package name is a valid Python identifier
	pkg = strings.ReplaceAll(pkg, "-", "_")
	// Remove leading slashes if any
	pkg = strings.TrimPrefix(pkg, "/")
	return pkg
}

func getPythonImportModuleName(file *protogen.File) string {
	// Convert proto package to Python import module name (with dots)
	pkg := string(file.Desc.Package())
	if pkg == "" {
		// Use filename without extension
		return strings.TrimSuffix(filepath.Base(file.Desc.Path()), ".proto")
	}

	// Keep dots for Python import statements
	// Ensure the package name is a valid Python identifier
	pkg = strings.ReplaceAll(pkg, "-", "_")
	return pkg
}

func getPythonFieldType(field *protogen.Field) string {
	baseType := ""
	switch field.Desc.Kind().String() {
	case "bool":
		baseType = "bool"
	case "int32", "sint32", "sfixed32", "int64", "sint64", "sfixed64",
		"uint32", "fixed32", "uint64", "fixed64":
		baseType = "int"
	case "float", "double":
		baseType = "float"
	case "string":
		baseType = "str"
	case "bytes":
		baseType = "bytes"
	case "enum":
		// Check if enum is using string constants
		directive := parsePuregenDirective(field.Enum.Comments)
		if directive == nil || directive.EnumType != "int" {
			// Default to string constants
			baseType = "str"
		} else {
			// Use integer enum type
			baseType = "int"
		}
	case "message":
		baseType = field.Message.GoIdent.GoName
	default:
		baseType = "Any"
	}

	if field.Desc.IsList() {
		if field.Desc.Kind().String() == "message" {
			return "List['" + baseType + "']"
		} else {
			return "List[" + baseType + "]"
		}
	}

	if field.Desc.Kind().String() == "message" {
		return "Optional['" + baseType + "']"
	}

	return baseType
}

func getPythonFieldName(goName string) string {
	// Convert PascalCase to snake_case
	// Handle consecutive uppercase letters properly (e.g., APIHost -> api_host, not a_p_i_host)
	if len(goName) == 0 {
		return goName
	}
	
	var result strings.Builder
	runes := []rune(goName)
	
	for i, r := range runes {
		if i > 0 && 'A' <= r && r <= 'Z' {
			// Check if the previous character was lowercase or if this is the end of consecutive caps
			prevIsLower := i > 0 && 'a' <= runes[i-1] && runes[i-1] <= 'z'
			nextIsLower := i < len(runes)-1 && 'a' <= runes[i+1] && runes[i+1] <= 'z'
			
			// Add underscore if:
			// 1. Previous char is lowercase (transition from lower to upper)
			// 2. Current char is uppercase and next char is lowercase (end of consecutive caps)
			if prevIsLower || (nextIsLower && i > 0) {
				result.WriteRune('_')
			}
		}
		result.WriteRune(r)
	}
	return strings.ToLower(result.String())
}

func getPythonMethodName(goName string) string {
	return getPythonFieldName(goName)
}

func getPythonDefaultValue(field *protogen.Field) string {
	// First check for puregen value directive
	directive := parseFieldDirective(field.Comments)
	if directive != nil && directive.Value != "" {
		// Convert the value to Python syntax based on field type
		switch field.Desc.Kind().String() {
		case "string":
			// Properly escape the string for Python
			escaped := strings.ReplaceAll(directive.Value, `"`, `\"`)
			return `"` + escaped + `"`
		case "bool":
			if directive.Value == "true" {
				return "True"
			} else if directive.Value == "false" {
				return "False"
			}
		case "int32", "sint32", "sfixed32", "int64", "sint64", "sfixed64",
			"uint32", "fixed32", "uint64", "fixed64":
			if _, err := strconv.ParseInt(directive.Value, 10, 64); err == nil {
				return directive.Value
			}
		case "float", "double":
			if _, err := strconv.ParseFloat(directive.Value, 64); err == nil {
				return directive.Value
			}
		}
	}
	
	// Special case: check for empty string directive
	if directive != nil && directive.Value == "" && field.Desc.Kind().String() == "string" {
		return `""`
	}

	// Fall back to standard default values
	if field.Desc.IsList() {
		return "field(default_factory=list)"
	}

	switch field.Desc.Kind().String() {
	case "bool":
		return "False"
	case "int32", "sint32", "sfixed32", "int64", "sint64", "sfixed64",
		"uint32", "fixed32", "uint64", "fixed64":
		return "0"
	case "float", "double":
		return "0.0"
	case "string":
		return `""`
	case "bytes":
		return "b''"
	case "enum":
		return "0"
	case "message":
		return "None"
	default:
		return "None"
	}
}

// Track created transport namespaces to avoid duplicates
var createdTransportNamespaces = make(map[string]bool)

// generateGlobalTransport creates a global Transport class in the specified namespace
func generateGlobalTransport(gen *protogen.Plugin, commonNamespace string) {
	// Only create once per namespace
	if createdTransportNamespaces[commonNamespace] {
		return
	}
	createdTransportNamespaces[commonNamespace] = true

	// Create package structure for parent directories
	createTransportPackageStructure(gen, commonNamespace)

	// Create the transport module file
	filename := strings.ReplaceAll(commonNamespace, ".", "/") + "/transport.py"
	
	// Check if transport.py already exists, if so, ignore it
	if fileExists(gen, filename) {
		return
	}
	
	g := gen.NewGeneratedFile(filename, "")

	// Generate file header
	g.P("# Code generated by protoc-gen-puregen. DO NOT EDIT.")
	g.P("# Global Transport interface")
	g.P()
	g.P("from abc import ABC, abstractmethod")
	g.P("from typing import Dict, Any")
	g.P()

	// Generate Transport interface
	g.P("class Transport(ABC):")
	g.P("    \"\"\"Abstract transport interface for client communication\"\"\"")
	g.P()
	g.P("    @abstractmethod")
	g.P("    def send(self, ctx: Dict[str, Any], method_name: str, input_data: Any, output_type: type) -> Any:")
	g.P("        \"\"\"Send request and return response\"\"\"")
	g.P("        pass")

	// Create a proper __init__.py file to export Transport
	initFilename := strings.ReplaceAll(commonNamespace, ".", "/") + "/__init__.py"
	
	// Check if __init__.py already exists, if so, ignore it
	if fileExists(gen, initFilename) {
		return
	}
	
	initG := gen.NewGeneratedFile(initFilename, "")
	initG.P("# Code generated by protoc-gen-puregen. DO NOT EDIT.")
	initG.P("from .transport import Transport")
	initG.P()
	initG.P("__all__ = ['Transport']")
}

// createTransportPackageStructure creates package directories for transport namespace
func createTransportPackageStructure(gen *protogen.Plugin, commonNamespace string) {
	if !strings.Contains(commonNamespace, ".") {
		// Single level package, nothing more to create
		return
	}

	// For multi-level packages, create parent __init__.py files
	parts := strings.Split(commonNamespace, ".")
	for i := 1; i < len(parts); i++ {
		parentPath := strings.Join(parts[:i], "/")
		initFile := parentPath + "/__init__.py"

		if !createdPythonPackages[initFile] {
			// Check if __init__.py already exists, if so, ignore it
			if fileExists(gen, initFile) {
				createdPythonPackages[initFile] = true
				continue
			}
			parentG := gen.NewGeneratedFile(initFile, "")
			parentG.P("# Code generated by protoc-gen-puregen. DO NOT EDIT.")
			parentG.P("# Package initialization file")
			createdPythonPackages[initFile] = true
		}
	}
}
