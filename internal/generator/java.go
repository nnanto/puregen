package generator

import (
	"path/filepath"
	"sort"
	"strings"
	"unicode"

	"google.golang.org/protobuf/compiler/protogen"
)

// titleCase converts a string to title case (capitalize first letter)
func titleCase(s string) string {
	if s == "" {
		return s
	}
	runes := []rune(s)
	runes[0] = unicode.ToUpper(runes[0])
	return string(runes)
}

// Track created metadata files to avoid duplicates
var createdJavaMetadataFiles = make(map[string]bool)

// formatJavaComment formats a comment for Java code
func formatJavaComment(comments protogen.CommentSet) []string {
	var result []string

	// Use leading comments if available, otherwise trailing
	comment := comments.Leading
	if comment == "" && comments.Trailing != "" {
		comment = comments.Trailing
	}

	if comment == "" {
		return result
	}

	// Split by lines and format each line
	lines := strings.Split(strings.TrimSpace(string(comment)), "\n")

	// If single line, use // style
	if len(lines) == 1 {
		result = append(result, "    // "+lines[0])
		return result
	}

	// Multi-line comment with /** */ style
	result = append(result, "    /**")
	for _, line := range lines {
		line = strings.TrimSpace(line)
		if line == "" {
			result = append(result, "     *")
		} else {
			result = append(result, "     * "+line)
		}
	}
	result = append(result, "     */")

	return result
}

// writeJavaComment writes formatted comments to the generator
func writeJavaComment(g *protogen.GeneratedFile, comments protogen.CommentSet) {
	commentLines := formatJavaComment(comments)
	for _, line := range commentLines {
		g.P(line)
	}
}



// GenerateJavaFile generates Java code for the given protobuf file
func GenerateJavaFile(gen *protogen.Plugin, file *protogen.File, commonNamespace string) {
	if len(file.Messages) == 0 && len(file.Services) == 0 {
		return
	}

	// Generate global transport if namespace is provided and we have services
	if commonNamespace != "" && len(file.Services) > 0 {
		generateGlobalTransportJava(gen, commonNamespace)
	}

	// Get package name
	javaPackage := getJavaPackage(file)
	packageDir := strings.ReplaceAll(javaPackage, ".", "/")

	// Collect and generate imported messages first
	importedMessages := collectImportedMessages(file)
	for _, message := range importedMessages {
		generateJavaMessage(gen, file, message, javaPackage, packageDir)
	}

	// Generate all enums (including nested and unreferenced)
	// Only generate file-level enums here; nested enums will be generated with their parent messages
	for _, enum := range file.Enums {
		generateJavaEnum(gen, file, enum, javaPackage, packageDir)
	}

	// Generate messages
	for _, message := range file.Messages {
		generateJavaMessage(gen, file, message, javaPackage, packageDir)
	}

	// Generate services
	for _, service := range file.Services {
		generateJavaService(gen, file, service, javaPackage, packageDir)
		// Generate method constants
		generateJavaMethodConstants(gen, file, service, javaPackage, packageDir)
		// Generate client
		generateJavaClient(gen, file, service, javaPackage, packageDir, commonNamespace)
	}
}

func generateJavaMethodConstants(gen *protogen.Plugin, _ *protogen.File, service *protogen.Service, javaPackage, packageDir string) {
	serviceName := service.GoName
	constantsFilename := filepath.Join(packageDir, serviceName+"Methods.java")
	g := gen.NewGeneratedFile(constantsFilename, "")

	g.P("// Code generated by protoc-gen-puregen. DO NOT EDIT.")
	g.P()
	g.P("package ", javaPackage, ";")
	g.P()
	g.P("import java.util.*;")
	g.P()

	g.P("public final class ", serviceName, "Methods {")
	g.P("    private ", serviceName, "Methods() {} // Prevent instantiation")
	g.P()

	for _, method := range service.Methods {
		constName := serviceName + "_" + method.GoName
		g.P("    public static final String ", constName, " = \"", constName, "\";")
	}
	g.P()

	// Generate method metadata map
	g.P("    public static final Map<String, Map<String, String>> METHOD_METADATA = new HashMap<>();")
	g.P("    static {")
	for _, method := range service.Methods {
		constName := serviceName + "_" + method.GoName
		metadata := parseMethodMetadata(method.Comments)
		if metadata != nil {
			g.P("        Map<String, String> ", strings.ToLower(method.GoName), "Metadata = new HashMap<>();")

			// Sort keys for consistent output
			var keys []string
			for key := range metadata {
				keys = append(keys, key)
			}
			sort.Strings(keys)

			for _, key := range keys {
				value := metadata[key]
				g.P("        ", strings.ToLower(method.GoName), "Metadata.put(\"", key, "\", \"", value, "\");")
			}
			g.P("        METHOD_METADATA.put(", constName, ", ", strings.ToLower(method.GoName), "Metadata);")
		}
	}
	g.P("    }")
	g.P("}")
}

func generateJavaEnum(gen *protogen.Plugin, _ *protogen.File, enum *protogen.Enum, javaPackage, packageDir string) {
	enumName := enum.GoIdent.GoName
	filename := filepath.Join(packageDir, enumName+".java")
	g := gen.NewGeneratedFile(filename, "")

	// Parse puregen directive to determine enum type
	directive := parsePuregenDirective(enum.Comments)
	useStringConstants := true // Default to string constants
	
	if directive != nil && directive.EnumType == "int" {
		useStringConstants = false
	}

	// Generate class header
	g.P("// Code generated by protoc-gen-puregen. DO NOT EDIT.")
	g.P()
	g.P("package ", javaPackage, ";")
	g.P()

	// Generate enum comment
	writeJavaComment(g, enum.Comments)

	if useStringConstants {
		// Generate string constants class
		g.P("public final class ", enumName, " {")
		g.P("    private ", enumName, "() {} // Prevent instantiation")
		g.P()

		for _, value := range enum.Values {
			valueName := strings.ToUpper(string(value.Desc.Name()))
			g.P("    public static final String ", valueName, " = \"", value.Desc.Name(), "\";")
		}
		g.P()

		// Generate array of all values for validation
		g.P("    public static final String[] VALUES = {")
		for i, value := range enum.Values {
			valueName := strings.ToUpper(string(value.Desc.Name()))
			if i == len(enum.Values)-1 {
				g.P("        ", valueName)
			} else {
				g.P("        ", valueName, ",")
			}
		}
		g.P("    };")
		g.P()

		// Generate validation method
		g.P("    public static boolean isValid(String value) {")
		g.P("        for (String v : VALUES) {")
		g.P("            if (v.equals(value)) {")
		g.P("                return true;")
		g.P("            }")
		g.P("        }")
		g.P("        return false;")
		g.P("    }")
		g.P("}")
	} else {
		// Generate traditional Java enum
		g.P("public enum ", enumName, " {")
		
		for i, value := range enum.Values {
			valueName := strings.ToUpper(string(value.Desc.Name()))
			if i == len(enum.Values)-1 {
				g.P("    ", valueName, "(", value.Desc.Number(), ");")
			} else {
				g.P("    ", valueName, "(", value.Desc.Number(), "),")
			}
		}
		g.P()

		// Generate fields and constructor
		g.P("    private final int value;")
		g.P()
		g.P("    ", enumName, "(int value) {")
		g.P("        this.value = value;")
		g.P("    }")
		g.P()

		// Generate getValue method
		g.P("    public int getValue() {")
		g.P("        return value;")
		g.P("    }")
		g.P()

		// Generate fromValue method
		g.P("    public static ", enumName, " fromValue(int value) {")
		g.P("        for (", enumName, " e : values()) {")
		g.P("            if (e.value == value) {")
		g.P("                return e;")
		g.P("            }")
		g.P("        }")
		g.P("        throw new IllegalArgumentException(\"Invalid ", enumName, " value: \" + value);")
		g.P("    }")
		g.P()

		// Generate isValid method
		g.P("    public static boolean isValid(int value) {")
		g.P("        for (", enumName, " e : values()) {")
		g.P("            if (e.value == value) {")
		g.P("                return true;")
		g.P("            }")
		g.P("        }")
		g.P("        return false;")
		g.P("    }")
		g.P("}")
	}

	// Generate separate metadata class for the enum if it has metadata
	enumMetadata := parseEnumMetadata(enum.Comments)
	if enumMetadata != nil {
		metadataFilename := filepath.Join(packageDir, enumName+"Metadata.java")
		
		// Check if we've already created this metadata file
		if createdJavaMetadataFiles[metadataFilename] {
			return
		}
		createdJavaMetadataFiles[metadataFilename] = true
		
		metaG := gen.NewGeneratedFile(metadataFilename, "")

		metaG.P("// Code generated by protoc-gen-puregen. DO NOT EDIT.")
		metaG.P()
		metaG.P("package ", javaPackage, ";")
		metaG.P()
		metaG.P("import java.util.*;")
		metaG.P()
		metaG.P("public final class ", enumName, "Metadata {")
		metaG.P("    private ", enumName, "Metadata() {} // Prevent instantiation")
		metaG.P()
		metaG.P("    public static final Map<String, String> METADATA = new HashMap<>();")
		metaG.P("    static {")
		// Sort keys for consistent output
		var keys []string
		for key := range enumMetadata {
			keys = append(keys, key)
		}
		sort.Strings(keys)

		for _, key := range keys {
			value := enumMetadata[key]
			metaG.P("        METADATA.put(\"", key, "\", \"", value, "\");")
		}
		metaG.P("    }")
		metaG.P("}")
	}
}

func generateJavaMessage(gen *protogen.Plugin, file *protogen.File, msg *protogen.Message, javaPackage, packageDir string) {
	filename := filepath.Join(packageDir, msg.GoIdent.GoName+".java")
	g := gen.NewGeneratedFile(filename, "")

	// Generate class header
	g.P("// Code generated by protoc-gen-puregen. DO NOT EDIT.")
	g.P()
	g.P("package ", javaPackage, ";")
	g.P()
	g.P("import java.util.*;")
	g.P("import java.io.*;")
	g.P("import com.fasterxml.jackson.annotation.*;")
	g.P("import com.fasterxml.jackson.databind.*;")
	g.P()

	// Generate class comment
	writeJavaComment(g, msg.Comments)

	// Generate class
	g.P("public class ", msg.GoIdent.GoName, " {")

	// Generate fields
	for _, field := range msg.Fields {
		// Generate field comment
		if commentLines := formatJavaComment(field.Comments); len(commentLines) > 0 {
			for _, line := range commentLines {
				g.P(line)
			}
		}

		fieldType := getJavaFieldType(field)
		fieldName := getJavaFieldName(field.GoName)
		g.P("    @JsonProperty(\"", field.Desc.JSONName(), "\")")
		end := ";"
		if field.Desc.IsList() {
			end = " = new ArrayList<>();"
		}
		g.P("    private ", fieldType, " ", fieldName, end)
		g.P()
	}

	// Generate default constructor
	g.P("    public ", msg.GoIdent.GoName, "() {}")
	g.P()

	// Generate getters and setters
	for _, field := range msg.Fields {
		fieldType := getJavaFieldType(field)
		fieldName := getJavaFieldName(field.GoName)
		methodName := titleCase(fieldName)

		g.P("    public ", fieldType, " get", methodName, "() {")
		g.P("        return ", fieldName, ";")
		g.P("    }")
		g.P()

		g.P("    public void set", methodName, "(", fieldType, " ", fieldName, ") {")
		g.P("        this.", fieldName, " = ", fieldName, ";")
		g.P("    }")
		g.P()

		// Add convenience methods for repeated fields
		if field.Desc.IsList() {
			elementType := strings.TrimPrefix(strings.TrimSuffix(fieldType, ">"), "List<")
			g.P("    public void add", methodName, "(", elementType, " item) {")
			g.P("        if (this.", fieldName, " == null) {")
			g.P("            this.", fieldName, " = new ArrayList<>();")
			g.P("        }")
			g.P("        this.", fieldName, ".add(item);")
			g.P("    }")
			g.P()
		}
	}

	// Generate builder pattern
	g.P("    public static class Builder {")
	g.P("        private ", msg.GoIdent.GoName, " instance = new ", msg.GoIdent.GoName, "();")
	g.P()

	for _, field := range msg.Fields {
		fieldType := getJavaFieldType(field)
		fieldName := getJavaFieldName(field.GoName)
		methodName := titleCase(fieldName)

		g.P("        public Builder set", methodName, "(", fieldType, " ", fieldName, ") {")
		g.P("            instance.set", methodName, "(", fieldName, ");")
		g.P("            return this;")
		g.P("        }")
		g.P()
	}

	g.P("        public ", msg.GoIdent.GoName, " build() {")
	g.P("            return instance;")
	g.P("        }")
	g.P("    }")
	g.P()

	// Generate validation method
	g.P("    public boolean validate() {")
	g.P("        // Add custom validation logic here")
	g.P("        return true;")
	g.P("    }")
	g.P()

	// Generate JSON serialization methods
	g.P("    public String toJson() throws Exception {")
	g.P("        ObjectMapper mapper = new ObjectMapper();")
	g.P("        return mapper.writeValueAsString(this);")
	g.P("    }")
	g.P()

	g.P("    public static ", msg.GoIdent.GoName, " fromJson(String json) throws Exception {")
	g.P("        ObjectMapper mapper = new ObjectMapper();")
	g.P("        return mapper.readValue(json, ", msg.GoIdent.GoName, ".class);")
	g.P("    }")
	g.P()

	g.P("}")

	// Generate nested enums
	for _, enum := range msg.Enums {
		generateJavaEnum(gen, file, enum, javaPackage, packageDir)
	}

	// Generate nested messages
	for _, nested := range msg.Messages {
		generateJavaMessage(gen, file, nested, javaPackage, packageDir)
	}

	// Generate message metadata if available
	messageMetadata := parseMessageMetadata(msg.Comments)
	if messageMetadata != nil {
		metadataFilename := filepath.Join(packageDir, msg.GoIdent.GoName+"Metadata.java")
		
		// Check if we've already created this metadata file
		if !createdJavaMetadataFiles[metadataFilename] {
			createdJavaMetadataFiles[metadataFilename] = true
			metaG := gen.NewGeneratedFile(metadataFilename, "")

			metaG.P("// Code generated by protoc-gen-puregen. DO NOT EDIT.")
			metaG.P()
			metaG.P("package ", javaPackage, ";")
			metaG.P()
			metaG.P("import java.util.*;")
			metaG.P()
			metaG.P("public final class ", msg.GoIdent.GoName, "Metadata {")
			metaG.P("    private ", msg.GoIdent.GoName, "Metadata() {} // Prevent instantiation")
			metaG.P()
			metaG.P("    public static final Map<String, String> METADATA = new HashMap<>();")
			metaG.P("    static {")
			// Sort keys for consistent output
			var keys []string
			for key := range messageMetadata {
				keys = append(keys, key)
			}
			sort.Strings(keys)

			for _, key := range keys {
				value := messageMetadata[key]
				metaG.P("        METADATA.put(\"", key, "\", \"", value, "\");")
			}
			metaG.P("    }")
			metaG.P("}")
		}
	}

	// Generate field constants and metadata if any fields have metadata
	hasFieldMetadata := false
	for _, field := range msg.Fields {
		fieldMetadata := parseFieldMetadata(field.Comments)
		if fieldMetadata != nil {
			hasFieldMetadata = true
			break
		}
	}

	if hasFieldMetadata {
		// Generate field metadata class
		fieldMetadataFilename := filepath.Join(packageDir, msg.GoIdent.GoName+"FieldMetadata.java")
		
		// Check if we've already created this metadata file
		if !createdJavaMetadataFiles[fieldMetadataFilename] {
			createdJavaMetadataFiles[fieldMetadataFilename] = true
			fieldG := gen.NewGeneratedFile(fieldMetadataFilename, "")

			fieldG.P("// Code generated by protoc-gen-puregen. DO NOT EDIT.")
			fieldG.P()
			fieldG.P("package ", javaPackage, ";")
			fieldG.P()
			fieldG.P("import java.util.*;")
			fieldG.P()
			fieldG.P("public final class ", msg.GoIdent.GoName, "FieldMetadata {")
			fieldG.P("    private ", msg.GoIdent.GoName, "FieldMetadata() {} // Prevent instantiation")
			fieldG.P()

			// Generate field constants
			fieldG.P("    // Field name constants")
			for _, field := range msg.Fields {
				fieldMetadata := parseFieldMetadata(field.Comments)
				if fieldMetadata != nil {
					constName := msg.GoIdent.GoName + "_" + field.GoName + "_FIELD"
					constValue := msg.GoIdent.GoName + "_" + field.GoName
					fieldG.P("    public static final String ", constName, " = \"", constValue, "\";")
				}
			}
			fieldG.P()

			// Generate field metadata map
			fieldG.P("    public static final Map<String, Map<String, String>> FIELD_METADATA = new HashMap<>();")
			fieldG.P("    static {")
			for _, field := range msg.Fields {
				fieldMetadata := parseFieldMetadata(field.Comments)
				if fieldMetadata != nil {
					constName := msg.GoIdent.GoName + "_" + field.GoName + "_FIELD"
					fieldVarName := strings.ToLower(field.GoName)
					fieldG.P("        Map<String, String> ", fieldVarName, "Meta = new HashMap<>();")

					// Sort keys for consistent output
					var keys []string
					for key := range fieldMetadata {
						keys = append(keys, key)
					}
					sort.Strings(keys)

					for _, key := range keys {
						value := fieldMetadata[key]
						fieldG.P("        ", fieldVarName, "Meta.put(\"", key, "\", \"", value, "\");")
					}
					fieldG.P("        FIELD_METADATA.put(", constName, ", ", fieldVarName, "Meta);")
				}
			}
			fieldG.P("    }")
			fieldG.P("}")
		}
	}
}

func generateJavaService(gen *protogen.Plugin, _ *protogen.File, service *protogen.Service, javaPackage, packageDir string) {
	serviceName := service.GoName

	// Generate interface
	interfaceFilename := filepath.Join(packageDir, serviceName+"Service.java")
	g := gen.NewGeneratedFile(interfaceFilename, "")

	g.P("// Code generated by protoc-gen-puregen. DO NOT EDIT.")
	g.P()
	g.P("package ", javaPackage, ";")
	g.P()

	// Generate service comment
	writeJavaComment(g, service.Comments)

	g.P("public interface ", serviceName, "Service {")
	for _, method := range service.Methods {
		// Generate method comment
		if commentLines := formatJavaComment(method.Comments); len(commentLines) > 0 {
			for _, line := range commentLines {
				g.P(line)
			}
		}

		inputType := method.Input.GoIdent.GoName
		outputType := method.Output.GoIdent.GoName
		g.P("    ", outputType, " ", getJavaMethodName(method.GoName), "(Map<String, Object> ctx, ", inputType, " request) throws Exception;")
	}
	g.P("}")

	// Generate default implementation
	implFilename := filepath.Join(packageDir, "Default"+serviceName+"Service.java")
	impl := gen.NewGeneratedFile(implFilename, "")

	impl.P("// Code generated by protoc-gen-puregen. DO NOT EDIT.")
	impl.P()
	impl.P("package ", javaPackage, ";")
	impl.P()

	impl.P("public class Default", serviceName, "Service implements ", serviceName, "Service {")
	for _, method := range service.Methods {
		// Generate method comment
		if commentLines := formatJavaComment(method.Comments); len(commentLines) > 0 {
			for _, line := range commentLines {
				impl.P(line)
			}
		}

		inputType := method.Input.GoIdent.GoName
		outputType := method.Output.GoIdent.GoName
		methodName := getJavaMethodName(method.GoName)

		impl.P("    @Override")
		impl.P("    public ", outputType, " ", methodName, "(Map<String, Object> ctx, ", inputType, " request) throws Exception {")
		impl.P("        // TODO: Implement ", methodName)
		impl.P("        throw new UnsupportedOperationException(\"Method ", methodName, " not implemented\");")
		impl.P("    }")
		impl.P()
	}
	impl.P("}")
}

func generateJavaClient(gen *protogen.Plugin, _ *protogen.File, service *protogen.Service, javaPackage, packageDir string, commonNamespace string) {
	serviceName := service.GoName

	// Only generate Transport interface if no global namespace is provided
	if commonNamespace == "" {
		// Generate Transport interface
		transportFilename := filepath.Join(packageDir, "Transport.java")
		t := gen.NewGeneratedFile(transportFilename, "")

		t.P("// Code generated by protoc-gen-puregen. DO NOT EDIT.")
		t.P()
		t.P("package ", javaPackage, ";")
		t.P()
		t.P("import java.util.*;")
		t.P()
		t.P("public interface Transport {")
		t.P("    <T> T send(Map<String, Object> ctx, String methodName, Object inputData, Class<T> responseClass) throws Exception;")
		t.P("}")
	}

	// Generate client class
	clientFilename := filepath.Join(packageDir, serviceName+"Client.java")
	g := gen.NewGeneratedFile(clientFilename, "")

	g.P("// Code generated by protoc-gen-puregen. DO NOT EDIT.")
	g.P()
	g.P("package ", javaPackage, ";")
	g.P()
	g.P("import java.util.*;")
	// Import global transport if namespace is provided
	if commonNamespace != "" {
		// Convert namespace to Java import
		transportPackage := strings.ReplaceAll(commonNamespace, ".", "/")
		g.P("import ", transportPackage, ".Transport;")
	}
	g.P()

	g.P("public class ", serviceName, "Client {")
	g.P("    private final Transport transport;")
	g.P()
	g.P("    public ", serviceName, "Client(Transport transport) {")
	g.P("        this.transport = transport;")
	g.P("    }")
	g.P()

	// Generate client methods
	for _, method := range service.Methods {
		// Generate method comment
		if commentLines := formatJavaComment(method.Comments); len(commentLines) > 0 {
			for _, line := range commentLines {
				g.P(line)
			}
		}

		inputType := method.Input.GoIdent.GoName
		outputType := method.Output.GoIdent.GoName
		methodName := getJavaMethodName(method.GoName)
		constName := serviceName + "Methods." + serviceName + "_" + method.GoName

		g.P("    public ", outputType, " ", methodName, "(Map<String, Object> ctx, ", inputType, " request) throws Exception {")
		g.P("        Map<String, Object> enhancedCtx = new HashMap<>(ctx != null ? ctx : new HashMap<>());")
		g.P("        Map<String, String> methodMetadata = ", serviceName, "Methods.METHOD_METADATA.get(", constName, ");")
		g.P("        if (methodMetadata != null) {")
		g.P("            enhancedCtx.put(\"method_metadata\", methodMetadata);")
		g.P("        }")
		g.P("        return transport.send(enhancedCtx, ", constName, ", request, ", outputType, ".class);")
		g.P("    }")
		g.P()
	}
	g.P("}")
}

func getJavaPackage(file *protogen.File) string {
	if file.Proto.GetOptions().GetJavaPackage() != "" {
		return file.Proto.GetOptions().GetJavaPackage()
	}

	// Convert proto package to Java package
	pkg := string(file.Desc.Package())

	// Reverse domain notation if it looks like a proper package
	parts := strings.Split(pkg, ".")
	if len(parts) >= 2 {
		// Reverse for Java convention
		for i, j := 0, len(parts)-1; i < j; i, j = i+1, j-1 {
			parts[i], parts[j] = parts[j], parts[i]
		}
	}

	return strings.Join(parts, ".")
}

func getJavaFieldType(field *protogen.Field) string {
	baseType := ""
	switch field.Desc.Kind().String() {
	case "bool":
		baseType = "boolean"
	case "int32", "sint32", "sfixed32":
		baseType = "int"
	case "int64", "sint64", "sfixed64":
		baseType = "long"
	case "uint32", "fixed32":
		baseType = "int"
	case "uint64", "fixed64":
		baseType = "long"
	case "float":
		baseType = "float"
	case "double":
		baseType = "double"
	case "string":
		baseType = "String"
	case "bytes":
		baseType = "byte[]"
	case "enum":
		// Check if enum is using string constants
		directive := parsePuregenDirective(field.Enum.Comments)
		if directive == nil || directive.EnumType != "int" {
			// Default to string constants
			baseType = "String"
		} else {
			// Use integer enum type
			baseType = field.Enum.GoIdent.GoName
		}
	case "message":
		baseType = field.Message.GoIdent.GoName
	default:
		baseType = "Object"
	}

	if field.Desc.IsList() {
		return "List<" + baseType + ">"
	}

	return baseType
}

func getJavaFieldName(goName string) string {
	if len(goName) == 0 {
		return goName
	}

	// Convert to camelCase
	// Handle consecutive uppercase letters properly (e.g., APIHost -> apiHost, not aPIHost)
	runes := []rune(goName)
	var result strings.Builder
	
	for i, r := range runes {
		if i == 0 {
			// First character is always lowercase
			result.WriteRune(unicode.ToLower(r))
		} else if 'A' <= r && r <= 'Z' {
			// Check if this is part of consecutive uppercase letters
			nextIsLower := i < len(runes)-1 && 'a' <= runes[i+1] && runes[i+1] <= 'z'
			prevIsUpper := i > 0 && 'A' <= runes[i-1] && runes[i-1] <= 'Z'
			
			// Keep uppercase if it's the start of a new word (not consecutive caps)
			// Make lowercase if it's in the middle of consecutive caps
			if prevIsUpper && !nextIsLower {
				result.WriteRune(unicode.ToLower(r))
			} else {
				result.WriteRune(r)
			}
		} else {
			result.WriteRune(r)
		}
	}
	return result.String()
}

func getJavaMethodName(goName string) string {
	return getJavaFieldName(goName)
}

// Track created transport namespaces to avoid duplicates for Java
var createdTransportNamespacesJava = make(map[string]bool)

// generateGlobalTransportJava creates a global Transport interface in the specified namespace
func generateGlobalTransportJava(gen *protogen.Plugin, commonNamespace string) {
	// Only create once per namespace
	if createdTransportNamespacesJava[commonNamespace] {
		return
	}
	createdTransportNamespacesJava[commonNamespace] = true

	// Convert namespace to package directory
	packageDir := strings.ReplaceAll(commonNamespace, ".", "/")

	// Create the transport Java file
	filename := filepath.Join(packageDir, "Transport.java")
	g := gen.NewGeneratedFile(filename, "")

	// Generate file header
	g.P("// Code generated by protoc-gen-puregen. DO NOT EDIT.")
	g.P("// Global Transport interface")
	g.P()
	g.P("package ", commonNamespace, ";")
	g.P()
	g.P("import java.util.*;")
	g.P()

	// Generate Transport interface
	g.P("/**")
	g.P(" * Transport interface for client communication")
	g.P(" */")
	g.P("public interface Transport {")
	g.P("    <T> T send(Map<String, Object> ctx, String methodName, Object inputData, Class<T> responseClass) throws Exception;")
	g.P("}")
}
