package generator

import (
	"path/filepath"
	"strings"

	"google.golang.org/protobuf/compiler/protogen"
)

// GenerateJavaFile generates Java code for the given protobuf file
func GenerateJavaFile(gen *protogen.Plugin, file *protogen.File) {
	if len(file.Messages) == 0 && len(file.Services) == 0 {
		return
	}

	// Get package name
	javaPackage := getJavaPackage(file)
	packageDir := strings.ReplaceAll(javaPackage, ".", "/")

	// Generate messages
	for _, message := range file.Messages {
		generateJavaMessage(gen, file, message, javaPackage, packageDir)
	}

	// Generate services
	for _, service := range file.Services {
		generateJavaService(gen, file, service, javaPackage, packageDir)
		// Generate method constants
		generateJavaMethodConstants(gen, file, service, javaPackage, packageDir)
		// Generate client
		generateJavaClient(gen, file, service, javaPackage, packageDir)
	}
}

func generateJavaMethodConstants(gen *protogen.Plugin, file *protogen.File, service *protogen.Service, javaPackage, packageDir string) {
	serviceName := service.GoName
	constantsFilename := filepath.Join(packageDir, serviceName+"Methods.java")
	g := gen.NewGeneratedFile(constantsFilename, "")

	g.P("// Code generated by protoc-gen-puregen. DO NOT EDIT.")
	g.P()
	g.P("package ", javaPackage, ";")
	g.P()

	g.P("public final class ", serviceName, "Methods {")
	g.P("    private ", serviceName, "Methods() {} // Prevent instantiation")
	g.P()

	for _, method := range service.Methods {
		constName := serviceName + "_" + method.GoName
		g.P("    public static final String ", constName, " = \"", constName, "\";")
	}
	g.P("}")
}

func generateJavaMessage(gen *protogen.Plugin, file *protogen.File, msg *protogen.Message, javaPackage, packageDir string) {
	filename := filepath.Join(packageDir, msg.GoIdent.GoName+".java")
	g := gen.NewGeneratedFile(filename, "")

	// Generate class header
	g.P("// Code generated by protoc-gen-puregen. DO NOT EDIT.")
	g.P()
	g.P("package ", javaPackage, ";")
	g.P()
	g.P("import java.util.*;")
	g.P("import java.io.*;")
	g.P("import com.fasterxml.jackson.annotation.*;")
	g.P("import com.fasterxml.jackson.databind.*;")
	g.P()

	// Generate class
	g.P("public class ", msg.GoIdent.GoName, " {")

	// Generate fields
	for _, field := range msg.Fields {
		fieldType := getJavaFieldType(field)
		fieldName := getJavaFieldName(field.GoName)
		g.P("    @JsonProperty(\"", field.Desc.JSONName(), "\")")
		end := ";"
		if field.Desc.IsList() {
			end = " = new ArrayList<>();"
		}
		g.P("    private ", fieldType, " ", fieldName, end)
		g.P()
	}

	// Generate default constructor
	g.P("    public ", msg.GoIdent.GoName, "() {}")
	g.P()

	// Generate getters and setters
	for _, field := range msg.Fields {
		fieldType := getJavaFieldType(field)
		fieldName := getJavaFieldName(field.GoName)
		methodName := strings.Title(fieldName)

		g.P("    public ", fieldType, " get", methodName, "() {")
		g.P("        return ", fieldName, ";")
		g.P("    }")
		g.P()

		g.P("    public void set", methodName, "(", fieldType, " ", fieldName, ") {")
		g.P("        this.", fieldName, " = ", fieldName, ";")
		g.P("    }")
		g.P()

		// Add convenience methods for repeated fields
		if field.Desc.IsList() {
			elementType := strings.TrimPrefix(strings.TrimSuffix(fieldType, ">"), "List<")
			g.P("    public void add", methodName, "(", elementType, " item) {")
			g.P("        if (this.", fieldName, " == null) {")
			g.P("            this.", fieldName, " = new ArrayList<>();")
			g.P("        }")
			g.P("        this.", fieldName, ".add(item);")
			g.P("    }")
			g.P()
		}
	}

	// Generate builder pattern
	g.P("    public static class Builder {")
	g.P("        private ", msg.GoIdent.GoName, " instance = new ", msg.GoIdent.GoName, "();")
	g.P()

	for _, field := range msg.Fields {
		fieldType := getJavaFieldType(field)
		fieldName := getJavaFieldName(field.GoName)
		methodName := strings.Title(fieldName)

		g.P("        public Builder set", methodName, "(", fieldType, " ", fieldName, ") {")
		g.P("            instance.set", methodName, "(", fieldName, ");")
		g.P("            return this;")
		g.P("        }")
		g.P()
	}

	g.P("        public ", msg.GoIdent.GoName, " build() {")
	g.P("            return instance;")
	g.P("        }")
	g.P("    }")
	g.P()

	// Generate validation method
	g.P("    public boolean validate() {")
	g.P("        // Add custom validation logic here")
	g.P("        return true;")
	g.P("    }")
	g.P()

	// Generate JSON serialization methods
	g.P("    public String toJson() throws Exception {")
	g.P("        ObjectMapper mapper = new ObjectMapper();")
	g.P("        return mapper.writeValueAsString(this);")
	g.P("    }")
	g.P()

	g.P("    public static ", msg.GoIdent.GoName, " fromJson(String json) throws Exception {")
	g.P("        ObjectMapper mapper = new ObjectMapper();")
	g.P("        return mapper.readValue(json, ", msg.GoIdent.GoName, ".class);")
	g.P("    }")
	g.P()

	g.P("}")

	// Generate nested messages
	for _, nested := range msg.Messages {
		generateJavaMessage(gen, file, nested, javaPackage, packageDir)
	}
}

func generateJavaService(gen *protogen.Plugin, file *protogen.File, service *protogen.Service, javaPackage, packageDir string) {
	serviceName := service.GoName

	// Generate interface
	interfaceFilename := filepath.Join(packageDir, serviceName+"Service.java")
	g := gen.NewGeneratedFile(interfaceFilename, "")

	g.P("// Code generated by protoc-gen-puregen. DO NOT EDIT.")
	g.P()
	g.P("package ", javaPackage, ";")
	g.P()

	g.P("public interface ", serviceName, "Service {")
	for _, method := range service.Methods {
		inputType := method.Input.GoIdent.GoName
		outputType := method.Output.GoIdent.GoName
		g.P("    ", outputType, " ", getJavaMethodName(method.GoName), "(Map<String, Object> ctx, ", inputType, " request) throws Exception;")
	}
	g.P("}")

	// Generate default implementation
	implFilename := filepath.Join(packageDir, "Default"+serviceName+"Service.java")
	impl := gen.NewGeneratedFile(implFilename, "")

	impl.P("// Code generated by protoc-gen-puregen. DO NOT EDIT.")
	impl.P()
	impl.P("package ", javaPackage, ";")
	impl.P()

	impl.P("public class Default", serviceName, "Service implements ", serviceName, "Service {")
	for _, method := range service.Methods {
		inputType := method.Input.GoIdent.GoName
		outputType := method.Output.GoIdent.GoName
		methodName := getJavaMethodName(method.GoName)

		impl.P("    @Override")
		impl.P("    public ", outputType, " ", methodName, "(Map<String, Object> ctx, ", inputType, " request) throws Exception {")
		impl.P("        // TODO: Implement ", methodName)
		impl.P("        throw new UnsupportedOperationException(\"Method ", methodName, " not implemented\");")
		impl.P("    }")
		impl.P()
	}
	impl.P("}")
}

func generateJavaClient(gen *protogen.Plugin, file *protogen.File, service *protogen.Service, javaPackage, packageDir string) {
	serviceName := service.GoName

	// Generate Transport interface
	transportFilename := filepath.Join(packageDir, "Transport.java")
	t := gen.NewGeneratedFile(transportFilename, "")

	t.P("// Code generated by protoc-gen-puregen. DO NOT EDIT.")
	t.P()
	t.P("package ", javaPackage, ";")
	t.P()
	t.P("import java.util.*;")
	t.P()
	t.P("public interface Transport {")
	t.P("    <T> T send(Map<String, Object> ctx, String methodName, Object inputData, Class<T> responseClass) throws Exception;")
	t.P("}")

	// Generate client class
	clientFilename := filepath.Join(packageDir, serviceName+"Client.java")
	g := gen.NewGeneratedFile(clientFilename, "")

	g.P("// Code generated by protoc-gen-puregen. DO NOT EDIT.")
	g.P()
	g.P("package ", javaPackage, ";")
	g.P()
	g.P("import java.util.*;")
	g.P()

	g.P("public class ", serviceName, "Client {")
	g.P("    private final Transport transport;")
	g.P()
	g.P("    public ", serviceName, "Client(Transport transport) {")
	g.P("        this.transport = transport;")
	g.P("    }")
	g.P()

	// Generate client methods
	for _, method := range service.Methods {
		inputType := method.Input.GoIdent.GoName
		outputType := method.Output.GoIdent.GoName
		methodName := getJavaMethodName(method.GoName)
		constName := serviceName + "Methods." + serviceName + "_" + method.GoName

		g.P("    public ", outputType, " ", methodName, "(Map<String, Object> ctx, ", inputType, " request) throws Exception {")
		g.P("        return transport.send(ctx, ", constName, ", request, ", outputType, ".class);")
		g.P("    }")
		g.P()
	}
	g.P("}")
}

func getJavaPackage(file *protogen.File) string {
	if file.Proto.GetOptions().GetJavaPackage() != "" {
		return file.Proto.GetOptions().GetJavaPackage()
	}

	// Convert proto package to Java package
	pkg := string(file.Desc.Package())

	// Reverse domain notation if it looks like a proper package
	parts := strings.Split(pkg, ".")
	if len(parts) >= 2 {
		// Reverse for Java convention
		for i, j := 0, len(parts)-1; i < j; i, j = i+1, j-1 {
			parts[i], parts[j] = parts[j], parts[i]
		}
	}

	return strings.Join(parts, ".")
}

func getJavaFieldType(field *protogen.Field) string {
	baseType := ""
	switch field.Desc.Kind().String() {
	case "bool":
		baseType = "boolean"
	case "int32", "sint32", "sfixed32":
		baseType = "int"
	case "int64", "sint64", "sfixed64":
		baseType = "long"
	case "uint32", "fixed32":
		baseType = "int"
	case "uint64", "fixed64":
		baseType = "long"
	case "float":
		baseType = "float"
	case "double":
		baseType = "double"
	case "string":
		baseType = "String"
	case "bytes":
		baseType = "byte[]"
	case "enum":
		baseType = field.Enum.GoIdent.GoName
	case "message":
		baseType = field.Message.GoIdent.GoName
	default:
		baseType = "Object"
	}

	if field.Desc.IsList() {
		return "List<" + baseType + ">"
	}

	return baseType
}

func getJavaFieldName(goName string) string {
	if len(goName) == 0 {
		return goName
	}

	// Convert to camelCase
	return strings.ToLower(goName[:1]) + goName[1:]
}

func getJavaMethodName(goName string) string {
	return getJavaFieldName(goName)
}
