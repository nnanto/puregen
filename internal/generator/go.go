package generator

import (
	"encoding/json"
	"sort"
	"strings"

	"google.golang.org/protobuf/compiler/protogen"
)

// parseMethodMetadata extracts metadata from method comments
func parseMethodMetadata(comments protogen.CommentSet) map[string]string {
	// Use leading comments if available, otherwise trailing
	comment := comments.Leading
	if comment == "" && comments.Trailing != "" {
		comment = comments.Trailing
	}

	if comment == "" {
		return nil
	}

	lines := strings.Split(strings.TrimSpace(string(comment)), "\n")
	for _, line := range lines {
		line = strings.TrimSpace(line)
		if strings.HasPrefix(line, "metadata:") {
			jsonStr := strings.TrimPrefix(line, "metadata:")
			jsonStr = strings.TrimSpace(jsonStr)

			var metadata map[string]string
			if err := json.Unmarshal([]byte(jsonStr), &metadata); err == nil {
				return metadata
			}
		}
	}
	return nil
}

// collectImportedMessages recursively collects all messages that are imported from other packages
func collectImportedMessages(file *protogen.File) []*protogen.Message {
	visited := make(map[string]bool)
	var importedMessages []*protogen.Message

	// Check all messages in the file for imported message references
	for _, message := range file.Messages {
		collectImportedFromMessage(message, file, visited, &importedMessages)
	}

	// Check service methods for imported message references
	for _, service := range file.Services {
		for _, method := range service.Methods {
			collectImportedFromMessage(method.Input, file, visited, &importedMessages)
			collectImportedFromMessage(method.Output, file, visited, &importedMessages)
		}
	}

	return importedMessages
}

// collectImportedFromMessage recursively collects imported messages from a message and its fields
func collectImportedFromMessage(msg *protogen.Message, currentFile *protogen.File, visited map[string]bool, importedMessages *[]*protogen.Message) {
	if msg == nil {
		return
	}

	messageKey := string(msg.Desc.FullName())

	// If this message is from an imported file and we haven't seen it before
	if !visited[messageKey] && isImportedMessage(msg, currentFile) {
		visited[messageKey] = true
		*importedMessages = append(*importedMessages, msg)
	}

	// Recursively check fields for imported message types
	for _, field := range msg.Fields {
		if field.Message != nil {
			collectImportedFromMessage(field.Message, currentFile, visited, importedMessages)
		}
	}

	// Check nested messages
	for _, nested := range msg.Messages {
		collectImportedFromMessage(nested, currentFile, visited, importedMessages)
	}
}

// isImportedMessage checks if a message is imported from another package
func isImportedMessage(msg *protogen.Message, currentFile *protogen.File) bool {
	if msg.Desc.ParentFile() == nil {
		return false
	}

	// Check if the message's package is different from the current file's package
	msgPackage := msg.Desc.ParentFile().Package()
	currentPackage := currentFile.Desc.Package()

	return msgPackage != currentPackage
}

// formatGoComment formats a comment for Go code
func formatGoComment(comments protogen.CommentSet) []string {
	var result []string

	// Use leading comments if available, otherwise trailing
	comment := comments.Leading
	if comment == "" && comments.Trailing != "" {
		comment = comments.Trailing
	}

	if comment == "" {
		return result
	}

	// Split by lines and format each line
	lines := strings.Split(strings.TrimSpace(string(comment)), "\n")
	for _, line := range lines {
		line = strings.TrimSpace(line)
		if line == "" {
			result = append(result, "//")
		} else {
			result = append(result, "// "+line)
		}
	}

	return result
}

// writeGoComment writes formatted comments to the generator
func writeGoComment(g *protogen.GeneratedFile, comments protogen.CommentSet) {
	commentLines := formatGoComment(comments)
	for _, line := range commentLines {
		g.P(line)
	}
}

// GenerateGoFile generates Go code for the given protobuf file
func GenerateGoFile(gen *protogen.Plugin, file *protogen.File, commonNamespace string) {
	if len(file.Messages) == 0 && len(file.Services) == 0 {
		return
	}

	// Generate global transport if namespace is provided and we have services
	if commonNamespace != "" && len(file.Services) > 0 {
		generateGlobalTransportGo(gen, commonNamespace)
	}

	filename := file.GeneratedFilenamePrefix + ".pb.go"
	g := gen.NewGeneratedFile(filename, file.GoImportPath)

	// Generate package declaration
	g.P("// Code generated by protoc-gen-puregen. DO NOT EDIT.")
	g.P()
	g.P("package ", file.GoPackageName)
	g.P()

	// Generate imports
	g.P("import (")
	if len(file.Services) > 0 {
		g.P(`"context"`)
	}
	g.P(`"encoding/json"`)
	if len(file.Services) > 0 {
		g.P(`"fmt"`)
	}
	// Import global transport if namespace is provided and we have services
	if commonNamespace != "" && len(file.Services) > 0 {
		// Convert namespace to Go import path
		importPath := strings.ReplaceAll(commonNamespace, ".", "/")
		g.P(`"`, importPath, `"`)
	}
	g.P(")")
	g.P()

	// Collect and generate imported messages first
	importedMessages := collectImportedMessages(file)
	if len(importedMessages) > 0 {
		g.P("// Imported Messages (redefined locally)")
		g.P()
		for _, msg := range importedMessages {
			generateGoMessage(g, msg)
		}
	}

	// Generate enums
	if len(file.Enums) > 0 {
		g.P("// Enums")
		g.P()
	}
	for _, enum := range file.Enums {
		generateGoEnum(g, enum)
	}

	// Generate messages
	if len(file.Messages) > 0 {
		g.P("// Messages")
		g.P()
	}
	for _, message := range file.Messages {
		generateGoMessage(g, message)
	}

	// Generate services
	if len(file.Services) > 0 {
		g.P("// Services")
		g.P()
	}
	for _, service := range file.Services {
		generateGoService(g, service)
	}

	// Generate method name constants
	if len(file.Services) > 0 {
		g.P("// Method name constants")
		g.P()
		for _, service := range file.Services {
			generateGoMethodConstants(g, service)
		}
	}

	if len(file.Services) > 0 {
		g.P("// Client")
		g.P()
	}
	for _, service := range file.Services {
		generateGoClient(g, service, commonNamespace)
	}
}

func generateGoMethodConstants(g *protogen.GeneratedFile, service *protogen.Service) {
	serviceName := service.GoName

	g.P("const (")
	for _, method := range service.Methods {
		constName := serviceName + "_" + method.GoName
		g.P("	", constName, " = \"", constName, "\"")
	}
	g.P(")")
	g.P()

	// Generate method metadata map
	g.P("var MethodMetadata = map[string]map[string]string{")
	for _, method := range service.Methods {
		constName := serviceName + "_" + method.GoName
		metadata := parseMethodMetadata(method.Comments)
		if metadata != nil {
			g.P("	", constName, ": {")

			// Sort keys for consistent output
			var keys []string
			for key := range metadata {
				keys = append(keys, key)
			}
			sort.Strings(keys)

			for _, key := range keys {
				value := metadata[key]
				g.P("		\"", key, "\": \"", value, "\",")
			}
			g.P("	},")
		}
	}
	g.P("}")
	g.P()
}

func generateGoEnum(g *protogen.GeneratedFile, enum *protogen.Enum) {
	enumName := enum.GoIdent.GoName

	// Generate type declaration
	g.P("type ", enumName, " int32")
	g.P()

	// Generate constants
	g.P("const (")
	for i, value := range enum.Values {
		valueName := value.GoIdent.GoName
		if i == 0 {
			g.P("	", valueName, " ", enumName, " = ", value.Desc.Number())
		} else {
			g.P("	", valueName, " = ", value.Desc.Number())
		}
	}
	g.P(")")
	g.P()

	// Generate value map for String() method
	g.P("var ", enumName, "_name = map[int32]string{")
	for _, value := range enum.Values {
		g.P("	", value.Desc.Number(), ": \"", value.Desc.Name(), "\",")
	}
	g.P("}")
	g.P()

	// Generate reverse map for parsing
	g.P("var ", enumName, "_value = map[string]int32{")
	for _, value := range enum.Values {
		g.P("	\"", value.Desc.Name(), "\": ", value.Desc.Number(), ",")
	}
	g.P("}")
	g.P()

	// Generate String() method
	g.P("func (x ", enumName, ") String() string {")
	g.P("	if name, ok := ", enumName, "_name[int32(x)]; ok {")
	g.P("		return name")
	g.P("	}")
	g.P("	return fmt.Sprintf(\"", enumName, "(%d)\", x)")
	g.P("}")
	g.P()

	// Generate Parse method
	g.P("func Parse", enumName, "(s string) (", enumName, ", error) {")
	g.P("	if value, ok := ", enumName, "_value[s]; ok {")
	g.P("		return ", enumName, "(value), nil")
	g.P("	}")
	g.P("	return 0, fmt.Errorf(\"invalid ", enumName, " value: %s\", s)")
	g.P("}")
	g.P()

	// Generate IsValid method
	g.P("func (x ", enumName, ") IsValid() bool {")
	g.P("	_, ok := ", enumName, "_name[int32(x)]")
	g.P("	return ok")
	g.P("}")
	g.P()
}

func generateGoMessage(g *protogen.GeneratedFile, msg *protogen.Message) {
	// Generate nested enums first
	for _, enum := range msg.Enums {
		generateGoEnum(g, enum)
	}

	// Generate message comment
	writeGoComment(g, msg.Comments)

	// Generate struct
	g.P("type ", msg.GoIdent.GoName, " struct {")
	for _, field := range msg.Fields {
		// Generate field comment
		if commentLines := formatGoComment(field.Comments); len(commentLines) > 0 {
			for _, line := range commentLines {
				g.P("	", line)
			}
		}

		fieldType := getGoFieldType(field)
		g.P("	", field.GoName, " ", fieldType, " `json:\"", field.Desc.JSONName(), "\"`")
	}
	g.P("}")
	g.P()

	// Generate constructor
	g.P("func New", msg.GoIdent.GoName, "() *", msg.GoIdent.GoName, " {")
	g.P("	return &", msg.GoIdent.GoName, "{}")
	g.P("}")
	g.P()

	// Generate validation method
	g.P("func (m *", msg.GoIdent.GoName, ") Validate() error {")
	g.P("	// Add custom validation logic here")
	g.P("	return nil")
	g.P("}")
	g.P()

	// Generate JSON serialization methods
	g.P("func (m *", msg.GoIdent.GoName, ") ToJSON() ([]byte, error) {")
	g.P("	return json.Marshal(m)")
	g.P("}")
	g.P()

	g.P("func (m *", msg.GoIdent.GoName, ") FromJSON(data []byte) error {")
	g.P("	return json.Unmarshal(data, m)")
	g.P("}")
	g.P()

	// Generate nested messages
	for _, nested := range msg.Messages {
		generateGoMessage(g, nested)
	}
}

func generateGoService(g *protogen.GeneratedFile, service *protogen.Service) {
	serviceName := service.GoName

	// Generate service comment
	writeGoComment(g, service.Comments)

	// Generate interface
	g.P("type ", serviceName, "Service interface {")
	for _, method := range service.Methods {
		// Generate method comment
		if commentLines := formatGoComment(method.Comments); len(commentLines) > 0 {
			for _, line := range commentLines {
				g.P("	", line)
			}
		}

		inputType := method.Input.GoIdent.GoName
		outputType := method.Output.GoIdent.GoName
		g.P("	", method.GoName, "(ctx context.Context, req *", inputType, ") (*", outputType, ", error)")
	}
	g.P("}")
	g.P()

	// Generate default implementation
	g.P("type Default", serviceName, "Service struct {}")
	g.P()

	for _, method := range service.Methods {
		// Generate method comment
		if commentLines := formatGoComment(method.Comments); len(commentLines) > 0 {
			for _, line := range commentLines {
				g.P(line)
			}
		}

		inputType := method.Input.GoIdent.GoName
		outputType := method.Output.GoIdent.GoName
		g.P("func (s *Default", serviceName, "Service) ", method.GoName, "(ctx context.Context, req *", inputType, ") (*", outputType, ", error) {")
		g.P("	// TODO: Implement ", method.GoName)
		g.P("	return &", outputType, "{}, fmt.Errorf(\"method ", method.GoName, " not implemented\")")
		g.P("}")
		g.P()
	}
}

func generateGoClient(g *protogen.GeneratedFile, service *protogen.Service, commonNamespace string) {
	serviceName := service.GoName

	// Only generate Transport interface if no global namespace is provided
	if commonNamespace == "" {
		// Generate Transport interface
		g.P("type Transport interface {")
		g.P("	Send(ctx context.Context, methodName string, inputData interface{}, outputType interface{}) (interface{}, error)")
		g.P("}")
		g.P()
	}

	// Generate client struct
	g.P("type ", serviceName, "Client struct {")
	g.P("	transport Transport")
	g.P("}")
	g.P()

	// Generate client constructor
	g.P("func New", serviceName, "Client(transport Transport) *", serviceName, "Client {")
	g.P("	return &", serviceName, "Client{transport: transport}")
	g.P("}")
	g.P()

	// Generate client methods
	for _, method := range service.Methods {
		// Generate method comment
		if commentLines := formatGoComment(method.Comments); len(commentLines) > 0 {
			for _, line := range commentLines {
				g.P(line)
			}
		}

		inputType := method.Input.GoIdent.GoName
		outputType := method.Output.GoIdent.GoName
		constName := serviceName + "_" + method.GoName
		g.P("func (c *", serviceName, "Client) ", method.GoName, "(ctx context.Context, req *", inputType, ") (*", outputType, ", error) {")
		g.P("	if metadata, exists := MethodMetadata[", constName, "]; exists {")
		g.P("		ctx = context.WithValue(ctx, \"method_metadata\", metadata)")
		g.P("	}")
		g.P("	result, err := c.transport.Send(ctx, ", constName, ", req, (*", outputType, ")(nil))")
		g.P("	if err != nil {")
		g.P("		return nil, err")
		g.P("	}")
		g.P("	if response, ok := result.(*", outputType, "); ok {")
		g.P("		return response, nil")
		g.P("	}")
		g.P("	return nil, fmt.Errorf(\"invalid response type for ", method.GoName, "\")")
		g.P("}")
		g.P()
	}
}

func getGoFieldType(field *protogen.Field) string {
	var baseType string

	switch field.Desc.Kind().String() {
	case "bool":
		baseType = "bool"
	case "int32", "sint32", "sfixed32":
		baseType = "int32"
	case "int64", "sint64", "sfixed64":
		baseType = "int64"
	case "uint32", "fixed32":
		baseType = "uint32"
	case "uint64", "fixed64":
		baseType = "uint64"
	case "float":
		baseType = "float32"
	case "double":
		baseType = "float64"
	case "string":
		baseType = "string"
	case "bytes":
		baseType = "[]byte"
	case "enum":
		baseType = field.Enum.GoIdent.GoName
	case "message":
		baseType = "*" + field.Message.GoIdent.GoName
	default:
		baseType = "interface{}"
	}

	// Handle repeated fields
	if field.Desc.IsList() {
		return "[]" + baseType
	}

	return baseType
}

// Track created transport namespaces to avoid duplicates for Go
var createdTransportNamespacesGo = make(map[string]bool)

// generateGlobalTransportGo creates a global Transport interface in the specified namespace
func generateGlobalTransportGo(gen *protogen.Plugin, commonNamespace string) {
	// Only create once per namespace
	if createdTransportNamespacesGo[commonNamespace] {
		return
	}
	createdTransportNamespacesGo[commonNamespace] = true

	// Create the transport Go file
	filename := strings.ReplaceAll(commonNamespace, ".", "/") + "/transport.go"
	g := gen.NewGeneratedFile(filename, "")

	// Get package name (last part of namespace)
	parts := strings.Split(commonNamespace, ".")
	packageName := parts[len(parts)-1]

	// Generate file header
	g.P("// Code generated by protoc-gen-puregen. DO NOT EDIT.")
	g.P("// Global Transport interface")
	g.P()
	g.P("package ", packageName)
	g.P()
	g.P("import (")
	g.P(`	"context"`)
	g.P(")")
	g.P()

	// Generate Transport interface
	g.P("// Transport defines the interface for client communication")
	g.P("type Transport interface {")
	g.P("	Send(ctx context.Context, methodName string, inputData interface{}, outputType interface{}) (interface{}, error)")
	g.P("}")
}
