package generator

import (
	"sort"
	"strconv"
	"strings"

	"google.golang.org/protobuf/compiler/protogen"
)

// formatGoComment formats a comment for Go code
func formatGoComment(comments protogen.CommentSet) []string {
	var result []string

	// Use leading comments if available, otherwise trailing
	comment := comments.Leading
	if comment == "" && comments.Trailing != "" {
		comment = comments.Trailing
	}

	if comment == "" {
		return result
	}

	// Filter out puregen directives before processing
	comment = protogen.Comments(filterPuregenDirectives(string(comment)))

	// Split by lines and format each line
	lines := strings.Split(strings.TrimSpace(string(comment)), "\n")
	for _, line := range lines {
		line = strings.TrimSpace(line)
		if line == "" {
			result = append(result, "//")
		} else {
			result = append(result, "// "+line)
		}
	}

	return result
}

// writeGoComment writes formatted comments to the generator
func writeGoComment(g *protogen.GeneratedFile, comments protogen.CommentSet) {
	commentLines := formatGoComment(comments)
	for _, line := range commentLines {
		g.P(line)
	}
}

// GenerateGoFile generates Go code for the given protobuf file
func GenerateGoFile(gen *protogen.Plugin, file *protogen.File, commonNamespace string) {
	if len(file.Messages) == 0 && len(file.Services) == 0 {
		return
	}

	// Generate global transport if namespace is provided and we have services
	if commonNamespace != "" && len(file.Services) > 0 {
		generateGlobalTransportGo(gen, commonNamespace)
	}

	filename := file.GeneratedFilenamePrefix + ".pb.go"
	g := gen.NewGeneratedFile(filename, file.GoImportPath)

	// Generate package declaration
	g.P("// Code generated by protoc-gen-puregen. DO NOT EDIT.")
	g.P()
	g.P("package ", file.GoPackageName)
	g.P()

	// Generate imports
	g.P("import (")
	if len(file.Services) > 0 {
		g.P(`"context"`)
	}
	g.P(`"encoding/json"`)
	if len(file.Services) > 0 {
		g.P(`"fmt"`)
	}
	
	// Add fmt import if we have any int enums
	hasIntEnums := false
	enumsForImport := collectAllEnums(file)
	for _, enum := range enumsForImport {
		directive := parsePuregenDirective(enum.Comments)
		if directive != nil && directive.EnumType == "int" {
			hasIntEnums = true
			break
		}
	}
	if hasIntEnums && len(file.Services) == 0 {
		g.P(`"fmt"`)
	}
	
	// Import global transport if namespace is provided and we have services
	if commonNamespace != "" && len(file.Services) > 0 {
		// Convert namespace to Go import path
		importPath := strings.ReplaceAll(commonNamespace, ".", "/")
		g.P(`"`, importPath, `"`)
	}
	g.P(")")
	g.P()

	// Collect and generate imported messages first
	importedMessages := collectImportedMessages(file)
	if len(importedMessages) > 0 {
		g.P("// Imported Messages (redefined locally)")
		g.P()
		for _, msg := range importedMessages {
			generateGoMessage(g, msg)
		}
	}

	// Generate all enums (including nested and unreferenced)
	allEnums := collectAllEnums(file)
	if len(allEnums) > 0 {
		g.P("// Enums")
		g.P()
	}
	for _, enum := range allEnums {
		generateGoEnum(g, enum)
	}

	// Generate messages
	if len(file.Messages) > 0 {
		g.P("// Messages")
		g.P()
	}
	for _, message := range file.Messages {
		generateGoMessage(g, message)
	}

	// Generate services
	if len(file.Services) > 0 {
		g.P("// Services")
		g.P()
	}
	for _, service := range file.Services {
		generateGoService(g, service)
	}

	// Generate method name constants
	if len(file.Services) > 0 {
		g.P("// Method name constants")
		g.P()
		for _, service := range file.Services {
			generateGoMethodConstants(g, service)
		}
	}

	if len(file.Services) > 0 {
		g.P("// Client")
		g.P()
	}
	for _, service := range file.Services {
		generateGoClient(g, service, commonNamespace)
	}
}

func generateGoMethodConstants(g *protogen.GeneratedFile, service *protogen.Service) {
	serviceName := service.GoName

	g.P("const (")
	for _, method := range service.Methods {
		constName := serviceName + "_" + method.GoName
		g.P("	", constName, " = \"", constName, "\"")
	}
	g.P(")")
	g.P()

	// Generate method metadata map
	g.P("var ", serviceName, "MethodMetadata = map[string]map[string]string{")
	for _, method := range service.Methods {
		constName := serviceName + "_" + method.GoName
		metadata := parseMethodMetadata(method.Comments)
		if metadata != nil {
			g.P("	", constName, ": {")

			// Sort keys for consistent output
			var keys []string
			for key := range metadata {
				keys = append(keys, key)
			}
			sort.Strings(keys)

			for _, key := range keys {
				value := metadata[key]
				g.P("		\"", key, "\": \"", value, "\",")
			}
			g.P("	},")
		}
	}
	g.P("}")
	g.P()
}

func generateGoEnum(g *protogen.GeneratedFile, enum *protogen.Enum) {
	enumName := enum.GoIdent.GoName

	// Parse puregen directive to determine enum type
	directive := parsePuregenDirective(enum.Comments)
	useStringConstants := true // Default to string constants
	
	if directive != nil && directive.EnumType == "int" {
		useStringConstants = false
	}

	if useStringConstants {
		// Generate string constants
		g.P("// ", enumName, " enum values as string constants")
		g.P("const (")
		for _, value := range enum.Values {
			valueName := value.GoIdent.GoName
			g.P("	", valueName, " = \"", value.Desc.Name(), "\"")
		}
		g.P(")")
		g.P()

		// Generate slice of all values for validation
		g.P("var ", enumName, "Values = []string{")
		for _, value := range enum.Values {
			valueName := value.GoIdent.GoName
			g.P("	", valueName, ",")
		}
		g.P("}")
		g.P()

		// Generate validation function
		g.P("func IsValid", enumName, "(value string) bool {")
		g.P("	for _, v := range ", enumName, "Values {")
		g.P("		if v == value {")
		g.P("			return true")
		g.P("		}")
		g.P("	}")
		g.P("	return false")
		g.P("}")
		g.P()
	} else {
		// Generate traditional int32 enum
		g.P("type ", enumName, " int32")
		g.P()

		// Generate constants
		g.P("const (")
		for i, value := range enum.Values {
			valueName := value.GoIdent.GoName
			if i == 0 {
				g.P("	", valueName, " ", enumName, " = ", value.Desc.Number())
			} else {
				g.P("	", valueName, " = ", value.Desc.Number())
			}
		}
		g.P(")")
		g.P()

		// Generate value map for String() method
		g.P("var ", enumName, "_name = map[int32]string{")
		for _, value := range enum.Values {
			g.P("	", value.Desc.Number(), ": \"", value.Desc.Name(), "\",")
		}
		g.P("}")
		g.P()

		// Generate reverse map for parsing
		g.P("var ", enumName, "_value = map[string]int32{")
		for _, value := range enum.Values {
			g.P("	\"", value.Desc.Name(), "\": ", value.Desc.Number(), ",")
		}
		g.P("}")
		g.P()

		// Generate String() method
		g.P("func (x ", enumName, ") String() string {")
		g.P("	if name, ok := ", enumName, "_name[int32(x)]; ok {")
		g.P("		return name")
		g.P("	}")
		g.P("	return fmt.Sprintf(\"", enumName, "(%d)\", x)")
		g.P("}")
		g.P()

		// Generate Parse method
		g.P("func Parse", enumName, "(s string) (", enumName, ", error) {")
		g.P("	if value, ok := ", enumName, "_value[s]; ok {")
		g.P("		return ", enumName, "(value), nil")
		g.P("	}")
		g.P("	return 0, fmt.Errorf(\"invalid ", enumName, " value: %s\", s)")
		g.P("}")
		g.P()

		// Generate IsValid method
		g.P("func (x ", enumName, ") IsValid() bool {")
		g.P("	_, ok := ", enumName, "_name[int32(x)]")
		g.P("	return ok")
		g.P("}")
		g.P()
	}

	// Generate enum metadata if available
	enumMetadata := parseEnumMetadata(enum.Comments)
	if enumMetadata != nil {
		g.P("// ", enumName, "Metadata contains metadata for ", enumName)
		g.P("var ", enumName, "Metadata = map[string]string{")
		// Sort keys for consistent output
		var keys []string
		for key := range enumMetadata {
			keys = append(keys, key)
		}
		sort.Strings(keys)

		for _, key := range keys {
			value := enumMetadata[key]
			g.P("	\"", key, "\": \"", value, "\",")
		}
		g.P("}")
		g.P()
	}
}

func generateGoMessage(g *protogen.GeneratedFile, msg *protogen.Message) {
	// Generate message comment
	writeGoComment(g, msg.Comments)

	// Generate struct
	g.P("type ", msg.GoIdent.GoName, " struct {")
	for _, field := range msg.Fields {
		// Generate field comment
		if commentLines := formatGoComment(field.Comments); len(commentLines) > 0 {
			for _, line := range commentLines {
				g.P("	", line)
			}
		}

		fieldType := getGoFieldType(field)
		g.P("	", field.GoName, " ", fieldType, " `json:\"", field.Desc.JSONName(), "\"`")
	}
	g.P("}")
	g.P()

	// Generate constructor
	g.P("func New", msg.GoIdent.GoName, "() *", msg.GoIdent.GoName, " {")
	
	// Check if any fields have default values
	hasDefaults := false
	for _, field := range msg.Fields {
		if getGoDefaultValue(field) != "" {
			hasDefaults = true
			break
		}
	}
	
	if hasDefaults {
		g.P("	return &", msg.GoIdent.GoName, "{")
		for _, field := range msg.Fields {
			defaultValue := getGoDefaultValue(field)
			if defaultValue != "" {
				g.P("		", field.GoName, ": ", defaultValue, ",")
			}
		}
		g.P("	}")
	} else {
		g.P("	return &", msg.GoIdent.GoName, "{}")
	}
	g.P("}")
	g.P()

	// Generate validation method
	g.P("func (m *", msg.GoIdent.GoName, ") Validate() error {")
	g.P("	// Add custom validation logic here")
	g.P("	return nil")
	g.P("}")
	g.P()

	// Generate JSON serialization methods
	g.P("func (m *", msg.GoIdent.GoName, ") ToJSON() ([]byte, error) {")
	g.P("	return json.Marshal(m)")
	g.P("}")
	g.P()

	g.P("func (m *", msg.GoIdent.GoName, ") FromJSON(data []byte) error {")
	g.P("	return json.Unmarshal(data, m)")
	g.P("}")
	g.P()

	// Generate nested messages
	for _, nested := range msg.Messages {
		generateGoMessage(g, nested)
	}

	// Generate message metadata if available
	messageMetadata := parseMessageMetadata(msg.Comments)
	if messageMetadata != nil {
		g.P("// ", msg.GoIdent.GoName, "Metadata contains metadata for ", msg.GoIdent.GoName)
		g.P("var ", msg.GoIdent.GoName, "Metadata = map[string]string{")
		// Sort keys for consistent output
		var keys []string
		for key := range messageMetadata {
			keys = append(keys, key)
		}
		sort.Strings(keys)

		for _, key := range keys {
			value := messageMetadata[key]
			g.P("	\"", key, "\": \"", value, "\",")
		}
		g.P("}")
		g.P()
	}

	// Generate field constants and metadata if any fields have metadata
	hasFieldMetadata := false
	for _, field := range msg.Fields {
		fieldMetadata := parseFieldMetadata(field.Comments)
		if fieldMetadata != nil {
			hasFieldMetadata = true
			break
		}
	}

	if hasFieldMetadata {
		// Generate field constants
		g.P("// Field name constants for ", msg.GoIdent.GoName)
		g.P("const (")
		for _, field := range msg.Fields {
			fieldMetadata := parseFieldMetadata(field.Comments)
			if fieldMetadata != nil {
				constName := msg.GoIdent.GoName + "_" + field.GoName + "_FIELD"
				constValue := msg.GoIdent.GoName + "_" + field.GoName
				g.P("	", constName, " = \"", constValue, "\"")
			}
		}
		g.P(")")
		g.P()

		// Generate MessageField metadata map
		g.P("// MessageField metadata for ", msg.GoIdent.GoName)
		g.P("var ", msg.GoIdent.GoName, "FieldMetadata = map[string]map[string]string{")
		for _, field := range msg.Fields {
			fieldMetadata := parseFieldMetadata(field.Comments)
			if fieldMetadata != nil {
				constName := msg.GoIdent.GoName + "_" + field.GoName + "_FIELD"
				g.P("	", constName, ": {")

				// Sort keys for consistent output
				var keys []string
				for key := range fieldMetadata {
					keys = append(keys, key)
				}
				sort.Strings(keys)

				for _, key := range keys {
					value := fieldMetadata[key]
					g.P("		\"", key, "\": \"", value, "\",")
				}
				g.P("	},")
			}
		}
		g.P("}")
		g.P()
	}
}

func generateGoService(g *protogen.GeneratedFile, service *protogen.Service) {
	serviceName := service.GoName

	// Generate service comment
	writeGoComment(g, service.Comments)

	// Generate interface
	g.P("type ", serviceName, "Service interface {")
	for _, method := range service.Methods {
		// Generate method comment
		if commentLines := formatGoComment(method.Comments); len(commentLines) > 0 {
			for _, line := range commentLines {
				g.P("	", line)
			}
		}

		inputType := method.Input.GoIdent.GoName
		outputType := method.Output.GoIdent.GoName
		g.P("	", method.GoName, "(ctx context.Context, req *", inputType, ") (*", outputType, ", error)")
	}
	g.P("}")
	g.P()

	// Generate default implementation
	g.P("type Default", serviceName, "Service struct {}")
	g.P()

	for _, method := range service.Methods {
		// Generate method comment
		if commentLines := formatGoComment(method.Comments); len(commentLines) > 0 {
			for _, line := range commentLines {
				g.P(line)
			}
		}

		inputType := method.Input.GoIdent.GoName
		outputType := method.Output.GoIdent.GoName
		g.P("func (s *Default", serviceName, "Service) ", method.GoName, "(ctx context.Context, req *", inputType, ") (*", outputType, ", error) {")
		g.P("	// TODO: Implement ", method.GoName)
		g.P("	return &", outputType, "{}, fmt.Errorf(\"method ", method.GoName, " not implemented\")")
		g.P("}")
		g.P()
	}
}

func generateGoClient(g *protogen.GeneratedFile, service *protogen.Service, commonNamespace string) {
	serviceName := service.GoName

	// Only generate Transport interface if no global namespace is provided
	if commonNamespace == "" {
		// Generate Transport interface
		g.P("type Transport interface {")
		g.P("	Send(ctx context.Context, methodName string, inputData interface{}, outputType interface{}) (interface{}, error)")
		g.P("}")
		g.P()
	}

	// Generate client struct
	g.P("type ", serviceName, "Client struct {")
	g.P("	transport Transport")
	g.P("}")
	g.P()

	// Generate client constructor
	g.P("func New", serviceName, "Client(transport Transport) *", serviceName, "Client {")
	g.P("	return &", serviceName, "Client{transport: transport}")
	g.P("}")
	g.P()

	// Generate client methods
	for _, method := range service.Methods {
		// Generate method comment
		if commentLines := formatGoComment(method.Comments); len(commentLines) > 0 {
			for _, line := range commentLines {
				g.P(line)
			}
		}

		inputType := method.Input.GoIdent.GoName
		outputType := method.Output.GoIdent.GoName
		constName := serviceName + "_" + method.GoName
		g.P("func (c *", serviceName, "Client) ", method.GoName, "(ctx context.Context, req *", inputType, ") (*", outputType, ", error) {")
		g.P("	if metadata, exists := ", serviceName, "MethodMetadata[", constName, "]; exists {")
		g.P("		ctx = context.WithValue(ctx, \"method_metadata\", metadata)")
		g.P("	}")
		g.P("	result, err := c.transport.Send(ctx, ", constName, ", req, (*", outputType, ")(nil))")
		g.P("	if err != nil {")
		g.P("		return nil, err")
		g.P("	}")
		g.P("	if response, ok := result.(*", outputType, "); ok {")
		g.P("		return response, nil")
		g.P("	}")
		g.P("	return nil, fmt.Errorf(\"invalid response type for ", method.GoName, "\")")
		g.P("}")
		g.P()
	}
}

func getGoFieldType(field *protogen.Field) string {
	var baseType string

	switch field.Desc.Kind().String() {
	case "bool":
		baseType = "bool"
	case "int32", "sint32", "sfixed32":
		baseType = "int32"
	case "int64", "sint64", "sfixed64":
		baseType = "int64"
	case "uint32", "fixed32":
		baseType = "uint32"
	case "uint64", "fixed64":
		baseType = "uint64"
	case "float":
		baseType = "float32"
	case "double":
		baseType = "float64"
	case "string":
		baseType = "string"
	case "bytes":
		baseType = "[]byte"
	case "enum":
		// Check if enum is using string constants
		directive := parsePuregenDirective(field.Enum.Comments)
		if directive == nil || directive.EnumType != "int" {
			// Default to string constants
			baseType = "string"
		} else {
			// Use integer enum type
			baseType = field.Enum.GoIdent.GoName
		}
	case "message":
		baseType = "*" + field.Message.GoIdent.GoName
	default:
		baseType = "interface{}"
	}

	// Handle repeated fields
	if field.Desc.IsList() {
		return "[]" + baseType
	}

	return baseType
}

// getGoDefaultValue returns the Go default value for a field based on puregen directive
func getGoDefaultValue(field *protogen.Field) string {
	directive := parseFieldDirective(field.Comments)
	if directive != nil && directive.Value != "" {
		// Convert the value to Go syntax based on field type
		switch field.Desc.Kind().String() {
		case "string":
			// Properly escape the string for Go
			escaped := strings.ReplaceAll(directive.Value, `"`, `\"`)
			return `"` + escaped + `"`
		case "bool":
			if directive.Value == "true" || directive.Value == "false" {
				return directive.Value
			}
		case "int32", "int64", "uint32", "uint64", "sint32", "sint64", "fixed32", "fixed64", "sfixed32", "sfixed64":
			// Validate that it's a valid number
			if _, err := strconv.ParseInt(directive.Value, 10, 64); err == nil {
				return directive.Value
			}
		case "float", "double":
			// Validate that it's a valid float
			if _, err := strconv.ParseFloat(directive.Value, 64); err == nil {
				return directive.Value
			}
		}
	}
	// Special case: check for empty string directive
	if directive != nil && directive.Value == "" && field.Desc.Kind().String() == "string" {
		return `""`
	}
	return ""
}

// Track created transport namespaces to avoid duplicates for Go
var createdTransportNamespacesGo = make(map[string]bool)

// generateGlobalTransportGo creates a global Transport interface in the specified namespace
func generateGlobalTransportGo(gen *protogen.Plugin, commonNamespace string) {
	// Only create once per namespace
	if createdTransportNamespacesGo[commonNamespace] {
		return
	}
	createdTransportNamespacesGo[commonNamespace] = true

	// Create the transport Go file
	filename := strings.ReplaceAll(commonNamespace, ".", "/") + "/transport.go"
	g := gen.NewGeneratedFile(filename, "")

	// Get package name (last part of namespace)
	parts := strings.Split(commonNamespace, ".")
	packageName := parts[len(parts)-1]

	// Generate file header
	g.P("// Code generated by protoc-gen-puregen. DO NOT EDIT.")
	g.P("// Global Transport interface")
	g.P()
	g.P("package ", packageName)
	g.P()
	g.P("import (")
	g.P(`	"context"`)
	g.P(")")
	g.P()

	// Generate Transport interface
	g.P("// Transport defines the interface for client communication")
	g.P("type Transport interface {")
	g.P("	Send(ctx context.Context, methodName string, inputData interface{}, outputType interface{}) (interface{}, error)")
	g.P("}")
}
